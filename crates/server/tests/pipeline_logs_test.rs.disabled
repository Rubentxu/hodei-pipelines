use async_trait::async_trait;
use axum::Json;
use axum::extract::{Path, State};
use flate2::Compression;
use flate2::write::GzEncoder;
use hodei_pipelines_application::{
    CreatePipelineRequest, ExecutePipelineRequest, ListPipelinesFilter, PipelineExecutionService,
    PipelineService, UpdatePipelineRequest,
};
use hodei_pipelines_domain::pipeline_execution::entities::execution::{
    ExecutionId, ExecutionStatus, PipelineExecution, StepExecution, StepExecutionStatus,
};
use hodei_pipelines_domain::pipeline_execution::entities::pipeline::{
    Pipeline, PipelineId, PipelineStatus,
};
use hodei_pipelines_domain::{JobId, Result};
use hodei_server::pipeline_api::{PipelineApiAppState, get_execution_logs_handler};
use std::collections::HashMap;
use std::io::Write;
use std::sync::{Arc, Mutex};
use uuid::Uuid;

// Mock PipelineService
struct MockPipelineService {
    pipelines: Arc<Mutex<HashMap<PipelineId, Pipeline>>>,
}

#[async_trait]
impl PipelineService for MockPipelineService {
    async fn create_pipeline(&self, _request: CreatePipelineRequest) -> Result<Pipeline> {
        unimplemented!()
    }

    async fn get_pipeline(&self, id: &PipelineId) -> Result<Option<Pipeline>> {
        let pipelines = self.pipelines.lock().unwrap();
        Ok(pipelines.get(id).cloned())
    }

    async fn list_pipelines(&self, _filter: Option<ListPipelinesFilter>) -> Result<Vec<Pipeline>> {
        unimplemented!()
    }

    async fn update_pipeline(
        &self,
        _id: &PipelineId,
        _request: UpdatePipelineRequest,
    ) -> Result<Pipeline> {
        unimplemented!()
    }

    async fn delete_pipeline(&self, _id: &PipelineId) -> Result<()> {
        unimplemented!()
    }

    async fn execute_pipeline(
        &self,
        _request: ExecutePipelineRequest,
    ) -> Result<PipelineExecution> {
        unimplemented!()
    }
}

// Mock PipelineExecutionService
struct MockPipelineExecutionService {
    executions: Arc<Mutex<HashMap<ExecutionId, PipelineExecution>>>,
}

#[async_trait]
impl PipelineExecutionService for MockPipelineExecutionService {
    async fn get_execution(&self, id: &ExecutionId) -> Result<Option<PipelineExecution>> {
        let executions = self.executions.lock().unwrap();
        Ok(executions.get(id).cloned())
    }

    async fn get_executions_for_pipeline(
        &self,
        _pipeline_id: &PipelineId,
    ) -> Result<Vec<PipelineExecution>> {
        unimplemented!()
    }

    async fn cancel_execution(&self, _id: &ExecutionId) -> Result<()> {
        unimplemented!()
    }

    async fn retry_execution(&self, _id: &ExecutionId) -> Result<ExecutionId> {
        unimplemented!()
    }
}

#[tokio::test]
async fn test_get_execution_logs_handler_success() {
    // 1. Setup Data
    let pipeline_id = PipelineId(Uuid::new_v4());
    let execution_id = ExecutionId(Uuid::new_v4());
    let step_id = hodei_pipelines_domain::pipeline::PipelineStepId::new();

    // Create compressed logs
    let log_content = "Log line 1\nLog line 2";
    let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
    encoder.write_all(log_content.as_bytes()).unwrap();
    let compressed_logs = encoder.finish().unwrap();

    // Create StepExecution with compressed logs
    let mut step_execution = StepExecution::new(step_id);
    step_execution.compressed_logs = Some(compressed_logs);
    step_execution.status =
        hodei_pipelines_domain::pipeline_execution::StepExecutionStatus::COMPLETED;
    // We need to set the step name somewhere, but StepExecution doesn't have a name field?
    // Wait, StepExecution has step_id. The name comes from the Pipeline definition.
    // The handler fetches the pipeline to map step_id to name.

    // So we need to ensure the Pipeline mock returns a pipeline that has a step with this step_id.
    let step_name = "test-step".to_string();
    let job_spec = hodei_pipelines_domain::job::JobSpec {
        name: "test-job".to_string(),
        image: "ubuntu".to_string(),
        command: vec!["echo".to_string()],
        resources: hodei_pipelines_domain::job::ResourceQuota::default(),
        timeout_ms: 30000,
        retries: 3,
        env: HashMap::new(),
        secret_refs: vec![],
    };

    // We need to construct a PipelineStep with the matching ID.
    // PipelineStep::new generates a random ID. We need to force it or use a builder if it allows setting ID.
    // PipelineStep struct has public fields?
    // crates/core/src/pipeline.rs:84: pub struct PipelineStep { pub id: PipelineStepId, ... }
    // Yes, fields are public.

    let pipeline_step = hodei_pipelines_domain::pipeline::PipelineStep {
        id: step_id,
        name: step_name.clone(),
        job_spec,
        depends_on: vec![],
        timeout_ms: 30000,
    };

    let execution = PipelineExecution {
        id: execution_id,
        pipeline_id,
        status: ExecutionStatus::COMPLETED,
        started_at: chrono::Utc::now(),
        completed_at: Some(chrono::Utc::now()),
        steps: vec![step_execution],
        variables: HashMap::new(),
        tenant_id: None,
        correlation_id: None,
    };

    let pipeline = Pipeline {
        id: pipeline_id,
        name: "Test Pipeline".to_string(),
        description: None,
        status: PipelineStatus::PENDING,
        steps: vec![pipeline_step],
        variables: HashMap::new(),
        created_at: chrono::Utc::now(),
        updated_at: chrono::Utc::now(),
        tenant_id: None,
        workflow_definition: serde_json::Value::Null,
    };

    // 2. Setup Mocks
    let mut pipelines_map = HashMap::new();
    pipelines_map.insert(pipeline_id.clone(), pipeline);
    let pipeline_service = Arc::new(MockPipelineService {
        pipelines: Arc::new(Mutex::new(pipelines_map)),
    });

    let mut executions_map = HashMap::new();
    executions_map.insert(execution_id.clone(), execution);
    let execution_service = Arc::new(MockPipelineExecutionService {
        executions: Arc::new(Mutex::new(executions_map)),
    });

    // 3. Setup App State
    let state = PipelineApiAppState {
        pipeline_service,
        execution_service,
    };

    // 4. Call Handler
    let result = get_execution_logs_handler(State(state), Path((pipeline_id, execution_id))).await;

    // 4. Verify
    assert!(result.is_ok());
    let Json(logs_dto) = result.unwrap();

    assert_eq!(logs_dto.execution_id, execution_id.0);
    assert_eq!(logs_dto.step_executions.len(), 1);

    let step_logs = &logs_dto.step_executions[0];
    assert_eq!(step_logs.step_name, "test-step");

    // Check log lines
    // "Log line 1\nLog line 2" -> 2 lines
    assert_eq!(step_logs.logs.len(), 2);
    assert_eq!(step_logs.logs[0].content, "Log line 1");
    assert_eq!(step_logs.logs[1].content, "Log line 2");
}
