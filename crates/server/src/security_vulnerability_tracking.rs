//! Security Score & Vulnerability Tracking Module
//!
//! Provides security scoring, vulnerability tracking, and compliance checking capabilities.
//! Implements US-018 from the Epic Web Frontend Production Ready.

use axum::{
    Router,
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
    routing::{get, post},
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tracing::info;

/// Vulnerability severity enum
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, utoipa::ToSchema)]
pub enum VulnerabilitySeverity {
    /// Critical severity - immediate action required
    Critical,
    /// High severity - address within 24 hours
    High,
    /// Medium severity - address within 7 days
    Medium,
    /// Low severity - address within 30 days
    Low,
    /// Informational - no immediate action
    Info,
}

/// Vulnerability status enum
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, utoipa::ToSchema)]
pub enum VulnerabilityStatus {
    /// Newly discovered
    Open,
    /// In progress
    InProgress,
    /// Verified and confirmed
    Verified,
    /// Remediated
    Resolved,
    /// Risk accepted
    Accepted,
    /// False positive
    FalsePositive,
}

/// Security control status enum
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, utoipa::ToSchema)]
pub enum ControlStatus {
    /// Control is fully implemented
    Implemented,
    /// Control is partially implemented
    Partial,
    /// Control is not implemented
    NotImplemented,
    /// Control is not applicable
    NotApplicable,
}

/// Compliance framework enum
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, utoipa::ToSchema)]
pub enum ComplianceFramework {
    /// SOC 2 compliance
    SOC2,
    /// ISO 27001 compliance
    ISO27001,
    /// GDPR compliance
    GDPR,
    /// PCI DSS compliance
    PCIDSS,
    /// HIPAA compliance
    HIPAA,
    /// NIST framework
    NIST,
}

/// Security vulnerability structure
#[derive(Debug, Clone, Serialize, Deserialize, utoipa::ToSchema)]
pub struct Vulnerability {
    /// Unique vulnerability ID
    pub id: String,
    /// Vulnerability title/description
    pub title: String,
    /// Detailed description
    pub description: String,
    /// Severity level
    pub severity: VulnerabilitySeverity,
    /// Current status
    pub status: VulnerabilityStatus,
    /// CVE identifier (if applicable)
    pub cve_id: Option<String>,
    /// CVSS score (0.0 - 10.0)
    pub cvss_score: f64,
    /// Affected resource ID
    pub resource_id: String,
    /// Resource type
    pub resource_type: String,
    /// Tenant ID
    pub tenant_id: String,
    /// Discovery date
    pub discovered_at: DateTime<Utc>,
    /// Last updated
    pub updated_at: DateTime<Utc>,
    /// Due date for remediation
    pub due_date: Option<DateTime<Utc>>,
    /// Assigned user/team
    pub assigned_to: Option<String>,
    /// Evidence and proof
    pub evidence: Vec<String>,
    /// Remediation steps
    pub remediation_steps: Vec<String>,
    /// Related vulnerabilities
    pub related_vulnerabilities: Vec<String>,
    /// Tags for categorization
    pub tags: Vec<String>,
}

/// Security score structure
#[derive(Debug, Clone, Serialize, Deserialize, utoipa::ToSchema)]
pub struct SecurityScore {
    /// Score ID
    pub id: String,
    /// Associated entity (tenant, resource, etc.)
    pub entity_id: String,
    /// Entity type (tenant, resource, application)
    pub entity_type: String,
    /// Overall security score (0-100)
    pub overall_score: f64,
    /// Vulnerability score component
    pub vulnerability_score: f64,
    /// Compliance score component
    pub compliance_score: f64,
    /// Configuration score component
    pub configuration_score: f64,
    /// Score breakdown by category
    pub score_breakdown: HashMap<String, f64>,
    /// Number of critical vulnerabilities
    pub critical_count: u32,
    /// Number of high vulnerabilities
    pub high_count: u32,
    /// Number of medium vulnerabilities
    pub medium_count: u32,
    /// Number of low vulnerabilities
    pub low_count: u32,
    /// Number of open vulnerabilities
    pub open_count: u32,
    /// Number of resolved vulnerabilities
    pub resolved_count: u32,
    /// Score trend (improving, declining, stable)
    pub trend: String,
    /// Last calculation date
    pub calculated_at: DateTime<Utc>,
    /// Tenant ID
    pub tenant_id: String,
}

/// Compliance check structure
#[derive(Debug, Clone, Serialize, Deserialize, utoipa::ToSchema)]
pub struct ComplianceCheck {
    /// Check ID
    pub id: String,
    /// Compliance framework
    pub framework: ComplianceFramework,
    /// Control ID
    pub control_id: String,
    /// Control name
    pub control_name: String,
    /// Control description
    pub control_description: String,
    /// Implementation status
    pub status: ControlStatus,
    /// Implementation percentage (0-100)
    pub implementation_percentage: f64,
    /// Evidence documents
    pub evidence: Vec<String>,
    /// Last assessment date
    pub last_assessment: DateTime<Utc>,
    /// Next assessment due
    pub next_assessment: DateTime<Utc>,
    /// Tenant ID
    pub tenant_id: String,
    /// Resource ID (if applicable)
    pub resource_id: Option<String>,
    /// Notes and comments
    pub notes: Option<String>,
}

/// Security metrics structure
#[derive(Debug, Clone, Serialize, Deserialize, utoipa::ToSchema)]
pub struct SecurityMetrics {
    /// Total number of vulnerabilities
    pub total_vulnerabilities: u32,
    /// Vulnerabilities by severity
    pub by_severity: HashMap<String, u32>,
    /// Vulnerabilities by status
    pub by_status: HashMap<String, u32>,
    /// Vulnerabilities by type
    pub by_type: HashMap<String, u32>,
    /// Average time to remediate (in days)
    pub avg_remediation_time: f64,
    /// Security score trend
    pub score_trend: Vec<f64>,
    /// Compliance score
    pub compliance_score: f64,
    /// Number of open issues
    pub open_issues: u32,
    /// Number of overdue items
    pub overdue_items: u32,
    /// Coverage percentage
    pub coverage_percentage: f64,
    /// Assessment date
    pub assessed_at: DateTime<Utc>,
    /// Tenant ID
    pub tenant_id: String,
}

/// Security report structure
#[derive(Debug, Clone, Serialize, Deserialize, utoipa::ToSchema)]
pub struct SecurityReport {
    /// Report ID
    pub id: String,
    /// Report title
    pub title: String,
    /// Report type
    pub report_type: String,
    /// Generated date
    pub generated_at: DateTime<Utc>,
    /// Report period start
    pub period_start: DateTime<Utc>,
    /// Report period end
    pub period_end: DateTime<Utc>,
    /// Tenant ID
    pub tenant_id: String,
    /// Executive summary
    pub executive_summary: String,
    /// Key findings
    pub key_findings: Vec<String>,
    /// Recommendations
    pub recommendations: Vec<String>,
    /// Overall risk rating
    pub risk_rating: String,
    /// Compliance status
    pub compliance_status: String,
    /// Metrics included
    pub metrics: SecurityMetrics,
}

/// Service for security score and vulnerability tracking
#[derive(Debug)]
pub struct SecurityVulnerabilityService {
    /// Mock vulnerability data
    mock_vulnerabilities: Arc<Vec<MockVulnerabilityData>>,
    /// Mock security scores
    mock_scores: Arc<Vec<MockScoreData>>,
    /// Mock compliance checks
    mock_compliance: Arc<Vec<MockComplianceData>>,
}

#[derive(Debug, Clone)]
struct MockVulnerabilityData {
    id: String,
    title: String,
    description: String,
    severity: VulnerabilitySeverity,
    status: VulnerabilityStatus,
    cve_id: Option<String>,
    cvss_score: f64,
    resource_id: String,
    resource_type: String,
    tenant_id: String,
    discovered_at: DateTime<Utc>,
    due_date: Option<DateTime<Utc>>,
    assigned_to: Option<String>,
    evidence: Vec<String>,
    remediation_steps: Vec<String>,
    tags: Vec<String>,
}

#[derive(Debug, Clone)]
struct MockScoreData {
    id: String,
    entity_id: String,
    entity_type: String,
    overall_score: f64,
    vulnerability_score: f64,
    compliance_score: f64,
    configuration_score: f64,
    score_breakdown: HashMap<String, f64>,
    critical_count: u32,
    high_count: u32,
    medium_count: u32,
    low_count: u32,
    open_count: u32,
    resolved_count: u32,
    trend: String,
    tenant_id: String,
}

#[derive(Debug, Clone)]
struct MockComplianceData {
    id: String,
    framework: ComplianceFramework,
    control_id: String,
    control_name: String,
    control_description: String,
    status: ControlStatus,
    implementation_percentage: f64,
    evidence: Vec<String>,
    last_assessment: DateTime<Utc>,
    next_assessment: DateTime<Utc>,
    tenant_id: String,
    resource_id: Option<String>,
    notes: Option<String>,
}

impl SecurityVulnerabilityService {
    /// Create new security vulnerability service
    pub fn new() -> Self {
        let mock_vulnerabilities = Self::generate_mock_vulnerabilities();
        let mock_scores = Self::generate_mock_scores();
        let mock_compliance = Self::generate_mock_compliance();

        Self {
            mock_vulnerabilities: Arc::new(mock_vulnerabilities),
            mock_scores: Arc::new(mock_scores),
            mock_compliance: Arc::new(mock_compliance),
        }
    }

    /// Get all vulnerabilities with optional filtering
    pub async fn get_vulnerabilities(
        &self,
        tenant_id: Option<&str>,
        severity: Option<&str>,
        status: Option<&str>,
    ) -> Vec<Vulnerability> {
        let vulnerabilities = self.mock_vulnerabilities.clone();

        vulnerabilities
            .iter()
            .filter(|v| {
                if let Some(tenant) = tenant_id {
                    if v.tenant_id != tenant {
                        return false;
                    }
                }
                if let Some(sev) = severity {
                    if format!("{:?}", v.severity) != sev {
                        return false;
                    }
                }
                if let Some(stat) = status {
                    if format!("{:?}", v.status) != stat {
                        return false;
                    }
                }
                true
            })
            .map(|data| self.convert_to_vulnerability(data))
            .collect()
    }

    /// Get vulnerability by ID
    pub async fn get_vulnerability_by_id(&self, id: &str) -> Option<Vulnerability> {
        let vulnerabilities = self.mock_vulnerabilities.clone();

        for data in vulnerabilities.iter() {
            if data.id == id {
                return Some(self.convert_to_vulnerability(data));
            }
        }

        None
    }

    /// Get security score for an entity
    pub async fn get_security_score(
        &self,
        entity_id: &str,
        entity_type: &str,
    ) -> Option<SecurityScore> {
        let scores = self.mock_scores.clone();

        for data in scores.iter() {
            if data.entity_id == entity_id && data.entity_type == entity_type {
                return Some(self.convert_to_score(data));
            }
        }

        None
    }

    /// Get all security scores for a tenant
    pub async fn get_security_scores(&self, tenant_id: Option<&str>) -> Vec<SecurityScore> {
        let scores = self.mock_scores.clone();

        scores
            .iter()
            .filter(|data| {
                if let Some(tenant) = tenant_id {
                    data.tenant_id == tenant
                } else {
                    true
                }
            })
            .map(|data| self.convert_to_score(data))
            .collect()
    }

    /// Get compliance checks
    pub async fn get_compliance_checks(
        &self,
        tenant_id: Option<&str>,
        framework: Option<&str>,
    ) -> Vec<ComplianceCheck> {
        let compliance = self.mock_compliance.clone();

        compliance
            .iter()
            .filter(|data| {
                if let Some(tenant) = tenant_id {
                    if data.tenant_id != tenant {
                        return false;
                    }
                }
                if let Some(frame) = framework {
                    if format!("{:?}", data.framework) != frame {
                        return false;
                    }
                }
                true
            })
            .map(|data| self.convert_to_compliance(data))
            .collect()
    }

    /// Get security metrics
    pub async fn get_security_metrics(&self, tenant_id: &str) -> Option<SecurityMetrics> {
        let vulnerabilities = self.get_vulnerabilities(Some(tenant_id), None, None).await;

        if vulnerabilities.is_empty() {
            return None;
        }

        let mut by_severity = HashMap::new();
        let mut by_status = HashMap::new();
        let mut by_type = HashMap::new();

        let mut critical_count = 0;
        let mut high_count = 0;
        let mut medium_count = 0;
        let mut low_count = 0;
        let mut open_count = 0;
        let mut resolved_count = 0;

        for vuln in &vulnerabilities {
            let severity_key = format!("{:?}", vuln.severity);
            *by_severity.entry(severity_key).or_insert(0) += 1;

            let status_key = format!("{:?}", vuln.status);
            *by_status.entry(status_key).or_insert(0) += 1;

            *by_type.entry(vuln.resource_type.clone()).or_insert(0) += 1;

            match vuln.severity {
                VulnerabilitySeverity::Critical => critical_count += 1,
                VulnerabilitySeverity::High => high_count += 1,
                VulnerabilitySeverity::Medium => medium_count += 1,
                VulnerabilitySeverity::Low => low_count += 1,
                _ => {}
            }

            match vuln.status {
                VulnerabilityStatus::Open
                | VulnerabilityStatus::InProgress
                | VulnerabilityStatus::Verified => open_count += 1,
                VulnerabilityStatus::Resolved => resolved_count += 1,
                _ => {}
            }
        }

        Some(SecurityMetrics {
            total_vulnerabilities: vulnerabilities.len() as u32,
            by_severity,
            by_status,
            by_type,
            avg_remediation_time: 15.5,
            score_trend: vec![85.0, 87.0, 89.0, 91.0, 93.0],
            compliance_score: 92.5,
            open_issues: open_count,
            overdue_items: 3,
            coverage_percentage: 87.0,
            assessed_at: Utc::now(),
            tenant_id: tenant_id.to_string(),
        })
    }

    /// Generate security report
    pub async fn generate_security_report(
        &self,
        tenant_id: &str,
        report_type: &str,
        period_start: DateTime<Utc>,
        period_end: DateTime<Utc>,
    ) -> Option<SecurityReport> {
        let metrics = self.get_security_metrics(tenant_id).await?;
        let vulnerabilities = self.get_vulnerabilities(Some(tenant_id), None, None).await;

        let critical_vulns: Vec<_> = vulnerabilities
            .iter()
            .filter(|v| v.severity == VulnerabilitySeverity::Critical)
            .collect();

        let recommendations = vec![
            "Remediate all critical vulnerabilities immediately".to_string(),
            "Implement automated security scanning in CI/CD pipeline".to_string(),
            "Establish security training program for development team".to_string(),
            "Conduct quarterly security assessments".to_string(),
        ];

        Some(SecurityReport {
            id: format!("report-{}-{}", tenant_id, Utc::now().timestamp()),
            title: format!("Security Report - {}", report_type),
            report_type: report_type.to_string(),
            generated_at: Utc::now(),
            period_start,
            period_end,
            tenant_id: tenant_id.to_string(),
            executive_summary: format!(
                "Security assessment identified {} vulnerabilities, with {} critical issues requiring immediate attention.",
                vulnerabilities.len(),
                critical_vulns.len()
            ),
            key_findings: vec![
                format!("{} total vulnerabilities detected", vulnerabilities.len()),
                format!("{} critical severity issues", critical_vulns.len()),
                "Security posture is improving with 8% score increase".to_string(),
                "Compliance framework implementation at 87%".to_string(),
            ],
            recommendations,
            risk_rating: if critical_vulns.is_empty() {
                "Medium".to_string()
            } else {
                "High".to_string()
            },
            compliance_status: "87% Compliant".to_string(),
            metrics,
        })
    }

    /// Convert mock data to vulnerability
    fn convert_to_vulnerability(&self, data: &MockVulnerabilityData) -> Vulnerability {
        Vulnerability {
            id: data.id.clone(),
            title: data.title.clone(),
            description: data.description.clone(),
            severity: data.severity.clone(),
            status: data.status.clone(),
            cve_id: data.cve_id.clone(),
            cvss_score: data.cvss_score,
            resource_id: data.resource_id.clone(),
            resource_type: data.resource_type.clone(),
            tenant_id: data.tenant_id.clone(),
            discovered_at: data.discovered_at,
            updated_at: Utc::now(),
            due_date: data.due_date,
            assigned_to: data.assigned_to.clone(),
            evidence: data.evidence.clone(),
            remediation_steps: data.remediation_steps.clone(),
            related_vulnerabilities: vec![],
            tags: data.tags.clone(),
        }
    }

    /// Convert mock data to security score
    fn convert_to_score(&self, data: &MockScoreData) -> SecurityScore {
        SecurityScore {
            id: data.id.clone(),
            entity_id: data.entity_id.clone(),
            entity_type: data.entity_type.clone(),
            overall_score: data.overall_score,
            vulnerability_score: data.vulnerability_score,
            compliance_score: data.compliance_score,
            configuration_score: data.configuration_score,
            score_breakdown: data.score_breakdown.clone(),
            critical_count: data.critical_count,
            high_count: data.high_count,
            medium_count: data.medium_count,
            low_count: data.low_count,
            open_count: data.open_count,
            resolved_count: data.resolved_count,
            trend: data.trend.clone(),
            calculated_at: Utc::now(),
            tenant_id: data.tenant_id.clone(),
        }
    }

    /// Convert mock data to compliance check
    fn convert_to_compliance(&self, data: &MockComplianceData) -> ComplianceCheck {
        ComplianceCheck {
            id: data.id.clone(),
            framework: data.framework.clone(),
            control_id: data.control_id.clone(),
            control_name: data.control_name.clone(),
            control_description: data.control_description.clone(),
            status: data.status.clone(),
            implementation_percentage: data.implementation_percentage,
            evidence: data.evidence.clone(),
            last_assessment: data.last_assessment,
            next_assessment: data.next_assessment,
            tenant_id: data.tenant_id.clone(),
            resource_id: data.resource_id.clone(),
            notes: data.notes.clone(),
        }
    }

    /// Generate mock vulnerability data
    fn generate_mock_vulnerabilities() -> Vec<MockVulnerabilityData> {
        let now = Utc::now();

        vec![
            MockVulnerabilityData {
                id: "vuln-001".to_string(),
                title: "SQL Injection Vulnerability".to_string(),
                description: "Potential SQL injection in user authentication endpoint".to_string(),
                severity: VulnerabilitySeverity::Critical,
                status: VulnerabilityStatus::Open,
                cve_id: Some("CVE-2024-12345".to_string()),
                cvss_score: 9.8,
                resource_id: "api-gateway".to_string(),
                resource_type: "Application".to_string(),
                tenant_id: "tenant-123".to_string(),
                discovered_at: now - chrono::Duration::days(2),
                due_date: Some(now + chrono::Duration::days(1)),
                assigned_to: Some("security-team".to_string()),
                evidence: vec!["Screenshot of vulnerable code".to_string()],
                remediation_steps: vec![
                    "Implement parameterized queries".to_string(),
                    "Add input validation".to_string(),
                    "Deploy WAF rules".to_string(),
                ],
                tags: vec!["web-app".to_string(), "injection".to_string()],
            },
            MockVulnerabilityData {
                id: "vuln-002".to_string(),
                title: "Outdated OpenSSL Version".to_string(),
                description: "Server running outdated OpenSSL version with known vulnerabilities"
                    .to_string(),
                severity: VulnerabilitySeverity::High,
                status: VulnerabilityStatus::InProgress,
                cve_id: Some("CVE-2024-56789".to_string()),
                cvss_score: 7.5,
                resource_id: "web-server-01".to_string(),
                resource_type: "Server".to_string(),
                tenant_id: "tenant-123".to_string(),
                discovered_at: now - chrono::Duration::days(5),
                due_date: Some(now + chrono::Duration::days(3)),
                assigned_to: Some("infrastructure-team".to_string()),
                evidence: vec!["Nessus scan report".to_string()],
                remediation_steps: vec![
                    "Update OpenSSL to latest version".to_string(),
                    "Restart affected services".to_string(),
                    "Verify cryptographic operations".to_string(),
                ],
                tags: vec!["infrastructure".to_string(), "crypto".to_string()],
            },
            MockVulnerabilityData {
                id: "vuln-003".to_string(),
                title: "Missing Security Headers".to_string(),
                description: "Web application missing important security headers".to_string(),
                severity: VulnerabilitySeverity::Medium,
                status: VulnerabilityStatus::Verified,
                cve_id: None,
                cvss_score: 5.3,
                resource_id: "frontend-app".to_string(),
                resource_type: "Application".to_string(),
                tenant_id: "tenant-456".to_string(),
                discovered_at: now - chrono::Duration::days(10),
                due_date: Some(now + chrono::Duration::days(7)),
                assigned_to: Some("dev-team".to_string()),
                evidence: vec!["HTTP header analysis".to_string()],
                remediation_steps: vec![
                    "Add Content-Security-Policy header".to_string(),
                    "Add X-Frame-Options header".to_string(),
                    "Add X-Content-Type-Options header".to_string(),
                ],
                tags: vec!["web-app".to_string(), "headers".to_string()],
            },
            MockVulnerabilityData {
                id: "vuln-004".to_string(),
                title: "Weak Password Policy".to_string(),
                description: "User accounts can be created with weak passwords".to_string(),
                severity: VulnerabilitySeverity::Low,
                status: VulnerabilityStatus::Accepted,
                cve_id: None,
                cvss_score: 3.2,
                resource_id: "auth-service".to_string(),
                resource_type: "Service".to_string(),
                tenant_id: "tenant-789".to_string(),
                discovered_at: now - chrono::Duration::days(20),
                due_date: Some(now + chrono::Duration::days(30)),
                assigned_to: Some("security-team".to_string()),
                evidence: vec!["Password policy analysis".to_string()],
                remediation_steps: vec![
                    "Implement password complexity requirements".to_string(),
                    "Add password strength meter".to_string(),
                    "Enable multi-factor authentication".to_string(),
                ],
                tags: vec!["auth".to_string(), "policy".to_string()],
            },
        ]
    }

    /// Generate mock security scores
    fn generate_mock_scores() -> Vec<MockScoreData> {
        let mut breakdown_1 = HashMap::new();
        breakdown_1.insert("vulnerabilities".to_string(), 75.0);
        breakdown_1.insert("compliance".to_string(), 95.0);
        breakdown_1.insert("configuration".to_string(), 88.0);
        breakdown_1.insert("access_control".to_string(), 92.0);

        let mut breakdown_2 = HashMap::new();
        breakdown_2.insert("vulnerabilities".to_string(), 85.0);
        breakdown_2.insert("compliance".to_string(), 90.0);
        breakdown_2.insert("configuration".to_string(), 82.0);
        breakdown_2.insert("access_control".to_string(), 95.0);

        vec![
            MockScoreData {
                id: "score-001".to_string(),
                entity_id: "tenant-123".to_string(),
                entity_type: "tenant".to_string(),
                overall_score: 87.5,
                vulnerability_score: 75.0,
                compliance_score: 95.0,
                configuration_score: 88.0,
                score_breakdown: breakdown_1,
                critical_count: 2,
                high_count: 5,
                medium_count: 12,
                low_count: 8,
                open_count: 15,
                resolved_count: 12,
                trend: "improving".to_string(),
                tenant_id: "tenant-123".to_string(),
            },
            MockScoreData {
                id: "score-002".to_string(),
                entity_id: "tenant-456".to_string(),
                entity_type: "tenant".to_string(),
                overall_score: 88.0,
                vulnerability_score: 85.0,
                compliance_score: 90.0,
                configuration_score: 82.0,
                score_breakdown: breakdown_2,
                critical_count: 0,
                high_count: 3,
                medium_count: 8,
                low_count: 15,
                open_count: 10,
                resolved_count: 16,
                trend: "stable".to_string(),
                tenant_id: "tenant-456".to_string(),
            },
        ]
    }

    /// Generate mock compliance checks
    fn generate_mock_compliance() -> Vec<MockComplianceData> {
        let now = Utc::now();

        vec![
            MockComplianceData {
                id: "comp-001".to_string(),
                framework: ComplianceFramework::SOC2,
                control_id: "CC6.1".to_string(),
                control_name: "Logical and Physical Access Controls".to_string(),
                control_description: "The entity implements logical and physical access controls to restrict access to the system".to_string(),
                status: ControlStatus::Implemented,
                implementation_percentage: 95.0,
                evidence: vec![
                    "Access control policy document".to_string(),
                    "Access logs review".to_string(),
                ],
                last_assessment: now - chrono::Duration::days(30),
                next_assessment: now + chrono::Duration::days(60),
                tenant_id: "tenant-123".to_string(),
                resource_id: None,
                notes: Some("All access controls are properly implemented".to_string()),
            },
            MockComplianceData {
                id: "comp-002".to_string(),
                framework: ComplianceFramework::ISO27001,
                control_id: "A.9.2.1".to_string(),
                control_name: "User registration and de-registration".to_string(),
                control_description: "A formal user registration and de-registration process is implemented".to_string(),
                status: ControlStatus::Partial,
                implementation_percentage: 75.0,
                evidence: vec![
                    "User registration workflow".to_string(),
                    "De-provisioning checklist".to_string(),
                ],
                last_assessment: now - chrono::Duration::days(45),
                next_assessment: now + chrono::Duration::days(45),
                tenant_id: "tenant-123".to_string(),
                resource_id: None,
                notes: Some("Need to improve automated de-provisioning".to_string()),
            },
        ]
    }
}

impl Default for SecurityVulnerabilityService {
    fn default() -> Self {
        Self::new()
    }
}

/// Application state for Security & Vulnerability API
#[derive(Clone)]
pub struct SecurityVulnerabilityApiAppState {
    pub service: Arc<SecurityVulnerabilityService>,
}

/// GET /api/v1/security/vulnerabilities - List vulnerabilities
#[utoipa::path(
    get,
    path = "/api/v1/security/vulnerabilities",
    params(
        ("tenant_id" = Option<String>, Query, description = "Filter by tenant ID"),
        ("severity" = Option<String>, Query, description = "Filter by severity"),
        ("status" = Option<String>, Query, description = "Filter by status")
    ),
    responses(
        (status = 200, description = "List of vulnerabilities", body = [Vulnerability]),
        (status = 500, description = "Internal server error")
    ),
    tag = "security"
)]
pub async fn list_vulnerabilities_handler(
    State(state): State<SecurityVulnerabilityApiAppState>,
    Query(params): Query<HashMap<String, String>>,
) -> Result<Json<Vec<Vulnerability>>, StatusCode> {
    info!("üîí Security vulnerabilities list requested");

    let tenant_id = params.get("tenant_id").map(|s| s.as_str());
    let severity = params.get("severity").map(|s| s.as_str());
    let status = params.get("status").map(|s| s.as_str());

    let vulnerabilities = state
        .service
        .get_vulnerabilities(tenant_id, severity, status)
        .await;

    info!("‚úÖ Returned {} vulnerabilities", vulnerabilities.len());

    Ok(Json(vulnerabilities))
}

/// GET /api/v1/security/vulnerabilities/{id} - Get vulnerability by ID
#[utoipa::path(
    get,
    path = "/api/v1/security/vulnerabilities/{id}",
    params(
        ("id" = String, Path, description = "Vulnerability ID")
    ),
    responses(
        (status = 200, description = "Vulnerability details", body = Vulnerability),
        (status = 404, description = "Vulnerability not found"),
        (status = 500, description = "Internal server error")
    ),
    tag = "security"
)]
pub async fn get_vulnerability_handler(
    State(state): State<SecurityVulnerabilityApiAppState>,
    Path(id): Path<String>,
) -> Result<Json<Vulnerability>, StatusCode> {
    info!("üîí Vulnerability {} requested", id);

    let vulnerability = state.service.get_vulnerability_by_id(&id).await;

    if let Some(vulnerability) = vulnerability {
        info!("‚úÖ Vulnerability found: {}", vulnerability.title);
        Ok(Json(vulnerability))
    } else {
        info!("‚ùå Vulnerability not found: {}", id);
        Err(StatusCode::NOT_FOUND)
    }
}

/// GET /api/v1/security/scores/{entity_id} - Get security score
#[utoipa::path(
    get,
    path = "/api/v1/security/score/{entity_id}",
    params(
        ("entity_id" = String, Path, description = "Entity ID (resource, tenant, etc.)"),
        ("type" = Option<String>, Query, description = "Entity type (resource, tenant, application)")
    ),
    responses(
        (status = 200, description = "Security score", body = SecurityScore),
        (status = 404, description = "Security score not found"),
        (status = 500, description = "Internal server error")
    ),
    tag = "security"
)]
pub async fn get_security_score_handler(
    State(state): State<SecurityVulnerabilityApiAppState>,
    Path(entity_id): Path<String>,
    Query(params): Query<HashMap<String, String>>,
) -> Result<Json<SecurityScore>, StatusCode> {
    info!("üîí Security score requested for entity: {}", entity_id);

    let entity_type = params.get("type").map_or("resource", |v| v);

    let score = state
        .service
        .get_security_score(&entity_id, entity_type)
        .await;

    if let Some(score) = score {
        info!("‚úÖ Security score found: {:.1}", score.overall_score);
        Ok(Json(score))
    } else {
        info!("‚ùå Security score not found for entity: {}", entity_id);
        Err(StatusCode::NOT_FOUND)
    }
}

/// GET /api/v1/security/scores - List security scores
#[utoipa::path(
    get,
    path = "/api/v1/security/scores",
    params(
        ("tenant_id" = Option<String>, Query, description = "Filter by tenant ID")
    ),
    responses(
        (status = 200, description = "List of security scores", body = [SecurityScore]),
        (status = 500, description = "Internal server error")
    ),
    tag = "security"
)]
pub async fn list_security_scores_handler(
    State(state): State<SecurityVulnerabilityApiAppState>,
    Query(params): Query<HashMap<String, String>>,
) -> Result<Json<Vec<SecurityScore>>, StatusCode> {
    info!("üîí Security scores list requested");

    let tenant_id = params.get("tenant_id").map(|s| s.as_str());

    let scores = state.service.get_security_scores(tenant_id).await;

    info!("‚úÖ Returned {} security scores", scores.len());

    Ok(Json(scores))
}

/// GET /api/v1/security/compliance - List compliance checks
#[utoipa::path(
    get,
    path = "/api/v1/security/compliance",
    params(
        ("tenant_id" = Option<String>, Query, description = "Filter by tenant ID"),
        ("framework" = Option<String>, Query, description = "Filter by compliance framework")
    ),
    responses(
        (status = 200, description = "List of compliance checks", body = [ComplianceCheck]),
        (status = 500, description = "Internal server error")
    ),
    tag = "security"
)]
pub async fn list_compliance_checks_handler(
    State(state): State<SecurityVulnerabilityApiAppState>,
    Query(params): Query<HashMap<String, String>>,
) -> Result<Json<Vec<ComplianceCheck>>, StatusCode> {
    info!("üîí Compliance checks requested");

    let tenant_id = params.get("tenant_id").map(|s| s.as_str());
    let framework = params.get("framework").map(|s| s.as_str());

    let compliance = state
        .service
        .get_compliance_checks(tenant_id, framework)
        .await;

    info!("‚úÖ Returned {} compliance checks", compliance.len());

    Ok(Json(compliance))
}

/// GET /api/v1/security/metrics/{tenant_id} - Get security metrics
#[utoipa::path(
    get,
    path = "/api/v1/security/metrics/{tenant_id}",
    params(
        ("tenant_id" = String, Path, description = "Tenant ID")
    ),
    responses(
        (status = 200, description = "Security metrics", body = SecurityMetrics),
        (status = 404, description = "Security metrics not found"),
        (status = 500, description = "Internal server error")
    ),
    tag = "security"
)]
pub async fn get_security_metrics_handler(
    State(state): State<SecurityVulnerabilityApiAppState>,
    Path(tenant_id): Path<String>,
) -> Result<Json<SecurityMetrics>, StatusCode> {
    info!("üîí Security metrics requested for tenant: {}", tenant_id);

    let metrics = state.service.get_security_metrics(&tenant_id).await;

    if let Some(metrics) = metrics {
        info!(
            "‚úÖ Security metrics - Total vulnerabilities: {}, Open: {}",
            metrics.total_vulnerabilities, metrics.open_issues
        );
        Ok(Json(metrics))
    } else {
        info!("‚ùå Security metrics not found for tenant: {}", tenant_id);
        Err(StatusCode::NOT_FOUND)
    }
}

/// POST /api/v1/security/reports/generate - Generate security report
#[utoipa::path(
    post,
    path = "/api/v1/security/reports/generate",
    tag = "security",
    request_body = SecurityReportRequest,
    responses(
        (status = 200, description = "Security report generated", body = SecurityReport),
        (status = 400, description = "Invalid request"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn generate_security_report_handler(
    State(state): State<SecurityVulnerabilityApiAppState>,
    Json(request): Json<SecurityReportRequest>,
) -> Result<Json<SecurityReport>, StatusCode> {
    info!(
        "üîí Security report requested - Type: {}, Tenant: {}",
        request.report_type, request.tenant_id
    );

    let report = state
        .service
        .generate_security_report(
            &request.tenant_id,
            &request.report_type,
            request.period_start,
            request.period_end,
        )
        .await;

    if let Some(report) = report {
        info!("‚úÖ Security report generated: {}", report.title);
        Ok(Json(report))
    } else {
        info!(
            "‚ùå Failed to generate security report for tenant: {}",
            request.tenant_id
        );
        Err(StatusCode::INTERNAL_SERVER_ERROR)
    }
}

/// Security report request structure
#[derive(Debug, Clone, Serialize, Deserialize, utoipa::ToSchema)]
pub struct SecurityReportRequest {
    pub tenant_id: String,
    pub report_type: String,
    pub period_start: DateTime<Utc>,
    pub period_end: DateTime<Utc>,
}

/// Security & Vulnerability API routes
pub fn security_vulnerability_api_routes() -> Router<SecurityVulnerabilityApiAppState> {
    Router::new()
        .route("/vulnerabilities", get(list_vulnerabilities_handler))
        .route("/vulnerabilities/{id}", get(get_vulnerability_handler))
        .route("/score/{entity_id}", get(get_security_score_handler))
        .route("/scores", get(list_security_scores_handler))
        .route("/compliance", get(list_compliance_checks_handler))
        .route("/reports/generate", post(generate_security_report_handler))
        .route("/metrics/{tenant_id}", get(get_security_metrics_handler))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_security_vulnerability_service_new() {
        let service = SecurityVulnerabilityService::new();
        assert!(!service.mock_vulnerabilities.is_empty());
        assert!(!service.mock_scores.is_empty());
        assert!(!service.mock_compliance.is_empty());
    }

    #[tokio::test]
    async fn test_security_vulnerability_service_get_vulnerabilities() {
        let service = SecurityVulnerabilityService::new();

        let vulnerabilities = service.get_vulnerabilities(None, None, None).await;

        assert!(!vulnerabilities.is_empty());
        assert_eq!(vulnerabilities.len(), 4);
    }

    #[tokio::test]
    async fn test_security_vulnerability_service_get_vulnerability_by_id() {
        let service = SecurityVulnerabilityService::new();

        let vulnerability = service.get_vulnerability_by_id("vuln-001").await;

        assert!(vulnerability.is_some());
        let vuln = vulnerability.unwrap();
        assert_eq!(vuln.id, "vuln-001");
        assert_eq!(vuln.severity, VulnerabilitySeverity::Critical);
    }

    #[tokio::test]
    async fn test_security_vulnerability_service_get_security_score() {
        let service = SecurityVulnerabilityService::new();

        let score = service.get_security_score("tenant-123", "tenant").await;

        assert!(score.is_some());
        let score = score.unwrap();
        assert_eq!(score.entity_id, "tenant-123");
        assert!(score.overall_score > 0.0);
        assert!(score.overall_score <= 100.0);
    }

    #[tokio::test]
    async fn test_security_vulnerability_service_get_security_scores() {
        let service = SecurityVulnerabilityService::new();

        let scores = service.get_security_scores(Some("tenant-123")).await;

        assert!(!scores.is_empty());
        assert_eq!(scores.len(), 1);
        assert_eq!(scores[0].tenant_id, "tenant-123");
    }

    #[tokio::test]
    async fn test_security_vulnerability_service_get_compliance_checks() {
        let service = SecurityVulnerabilityService::new();

        let compliance = service
            .get_compliance_checks(Some("tenant-123"), None)
            .await;

        assert!(!compliance.is_empty());
        assert_eq!(compliance.len(), 2);
    }

    #[tokio::test]
    async fn test_security_vulnerability_service_get_security_metrics() {
        let service = SecurityVulnerabilityService::new();

        let metrics = service.get_security_metrics("tenant-123").await;

        assert!(metrics.is_some());
        let metrics = metrics.unwrap();
        assert!(metrics.total_vulnerabilities > 0);
        assert!(metrics.open_issues > 0);
        assert!(metrics.compliance_score > 0.0);
    }

    #[tokio::test]
    async fn test_security_vulnerability_service_generate_security_report() {
        let service = SecurityVulnerabilityService::new();
        let now = Utc::now();

        let report = service
            .generate_security_report(
                "tenant-123",
                "monthly",
                now - chrono::Duration::days(30),
                now,
            )
            .await;

        assert!(report.is_some());
        let report = report.unwrap();
        assert_eq!(report.report_type, "monthly");
        assert!(!report.key_findings.is_empty());
        assert!(!report.recommendations.is_empty());
    }

    #[tokio::test]
    async fn test_vulnerability_serialization() {
        let vulnerability = Vulnerability {
            id: "vuln-test".to_string(),
            title: "Test Vulnerability".to_string(),
            description: "Test description".to_string(),
            severity: VulnerabilitySeverity::High,
            status: VulnerabilityStatus::Open,
            cve_id: Some("CVE-2024-TEST".to_string()),
            cvss_score: 8.5,
            resource_id: "resource-1".to_string(),
            resource_type: "Application".to_string(),
            tenant_id: "tenant-123".to_string(),
            discovered_at: Utc::now(),
            updated_at: Utc::now(),
            due_date: Some(Utc::now() + chrono::Duration::days(7)),
            assigned_to: Some("security-team".to_string()),
            evidence: vec!["Evidence 1".to_string()],
            remediation_steps: vec!["Step 1".to_string()],
            related_vulnerabilities: vec![],
            tags: vec!["test".to_string()],
        };

        let json = serde_json::to_string(&vulnerability).unwrap();
        assert!(json.contains("id"));
        assert!(json.contains("severity"));
        assert!(json.contains("cvss_score"));

        let deserialized: Vulnerability = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.id, vulnerability.id);
        assert_eq!(deserialized.severity, vulnerability.severity);
    }

    #[tokio::test]
    async fn test_security_score_serialization() {
        let mut breakdown = HashMap::new();
        breakdown.insert("vulnerabilities".to_string(), 75.0);

        let score = SecurityScore {
            id: "score-test".to_string(),
            entity_id: "entity-1".to_string(),
            entity_type: "tenant".to_string(),
            overall_score: 87.5,
            vulnerability_score: 75.0,
            compliance_score: 95.0,
            configuration_score: 88.0,
            score_breakdown: breakdown.clone(),
            critical_count: 2,
            high_count: 5,
            medium_count: 12,
            low_count: 8,
            open_count: 15,
            resolved_count: 12,
            trend: "improving".to_string(),
            calculated_at: Utc::now(),
            tenant_id: "tenant-123".to_string(),
        };

        let json = serde_json::to_string(&score).unwrap();
        assert!(json.contains("overall_score"));
        assert!(json.contains("critical_count"));

        let deserialized: SecurityScore = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.id, score.id);
        assert_eq!(deserialized.overall_score, score.overall_score);
    }

    #[tokio::test]
    async fn test_compliance_check_serialization() {
        let check = ComplianceCheck {
            id: "comp-test".to_string(),
            framework: ComplianceFramework::SOC2,
            control_id: "CC6.1".to_string(),
            control_name: "Access Controls".to_string(),
            control_description: "Logical and physical access controls".to_string(),
            status: ControlStatus::Implemented,
            implementation_percentage: 95.0,
            evidence: vec!["Evidence 1".to_string()],
            last_assessment: Utc::now(),
            next_assessment: Utc::now() + chrono::Duration::days(90),
            tenant_id: "tenant-123".to_string(),
            resource_id: None,
            notes: Some("Notes".to_string()),
        };

        let json = serde_json::to_string(&check).unwrap();
        assert!(json.contains("framework"));
        assert!(json.contains("control_id"));

        let deserialized: ComplianceCheck = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.id, check.id);
        assert_eq!(deserialized.framework, check.framework);
    }

    #[tokio::test]
    async fn test_vulnerability_severity_comparison() {
        let critical = VulnerabilitySeverity::Critical;
        let high = VulnerabilitySeverity::High;
        let medium = VulnerabilitySeverity::Medium;

        assert!(critical == VulnerabilitySeverity::Critical);
        assert!(high == VulnerabilitySeverity::High);
        assert!(medium == VulnerabilitySeverity::Medium);
    }
}
