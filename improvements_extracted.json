{
  "mejoras": [],
  "code_smells": [],
  "sospechosos": [],
  "bugs": [
    {
      "num": "3",
      "file": "crates/adapters/src/bus/nats.rs",
      "layer": "Infrastructure",
      "ddd_type": "Adapter",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Separación clara entre configuración y implementación. **Code Smell**: Método `subscribe()` en línea 619-622 llama a sí mismo (recursión infinita). **Crítico**: ¡BUG! Línea 620 llama a `self.subscribe()` en lugar de `self.subscribe_with_subject(\"*\")`."
    },
    {
      "num": "13",
      "file": "crates/adapters/src/metrics_persistence_service.rs",
      "layer": "Infrastructure",
      "ddd_type": "Service + Adapter",
      "text": "BUG identificado",
      "full_comment": "**Buen patrón**: Service pattern para background tasks. **Code Smell**: Dos implementaciones de `clone()` (líneas 222-230 y 232-240) - duplicación. **Bug**: Línea 223-230 define `fn clone(&self)` que shadowea el trait `Clone`."
    },
    {
      "num": "24",
      "file": "crates/adapters/src/redb.rs",
      "layer": "Infrastructure",
      "ddd_type": "Repository + Adapter",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Repository pattern con embedded database y transacciones ACID. **Buen patrón**: Comprehensive test suite incluido (líneas 550-845). **Code Smell**: `eprintln!` debugging statements en producción (líneas 78-106). **Bug**: `bytes_to_job()` (líneas 77-109) usa `eprintln!` que no debería estar en código de producción. **Mejora**: `assign_worker()` (líneas 318-342) y `set_job_duration()` (líneas 454-458) son no-ops."
    },
    {
      "num": "28",
      "file": "crates/adapters/src/security/masking.rs",
      "layer": "Infrastructure",
      "ddd_type": "Adapter + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Adapter pattern para SecretMasker port. **Buen patrón**: `MaskingConfig` (líneas 6-11) como Value Object. **Code Smell**: `unwrap_or_else` en línea 23 usa fallback hardcoded `[\"secret\"]` - debería fallar explícitamente si patterns son inválidos. **Bug**: Línea 23 - si `AhoCorasick::new(&config.patterns)` falla, usa fallback `[\"secret\"]` silenciosamente. **Mejora**: `mask_text()` (líneas 35-47) ignora parámetro `_source` - viola interfaz."
    },
    {
      "num": "32",
      "file": "crates/adapters/src/worker_client.rs",
      "layer": "Infrastructure",
      "ddd_type": "Adapter + Factory + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Multiple adapter implementations para WorkerClient port. **Buen patrón**: Factory pattern para crear diferentes tipos de clientes (líneas 966-1012). **Code Smell**: Línea 124 usa `unwrap_or(0)` en parsing de CPU times - podría enmascarar errores. **Bug**: Línea 593-595 en `get_worker_status()` no parsea `current_jobs` del response proto. **Mejora**: `MetricsCollector` (líneas 71-379) es muy específico de Linux `/proc` filesystem."
    },
    {
      "num": "34",
      "file": "crates/core/src/circuit_breaker.rs",
      "layer": "Core Domain",
      "ddd_type": "Domain Service + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Domain Service para circuit breaker pattern. **Buen patrón**: `CircuitBreakerConfig` (líneas 9-34) como Value Object con defaults. **Code Smell**: Línea 68-71 implementa `default()` pero usa `#[allow(clippy::should_implement_trait)]` - debería implementar `Default` trait. **Bug**: Línea 150-159 `Clone` implementation resets state - esto puede ser intencional pero es contra-intuitivo. **Mejora**: `execute()` (líneas 73-94) usa `Box<dyn std::error::Error + Send + Sync>` que es muy genérico."
    },
    {
      "num": "37",
      "file": "crates/core/src/domain_services/priority_calculator.rs",
      "layer": "Core Domain",
      "ddd_type": "Domain Service",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Domain Service complejo con múltiples algoritmos de scheduling. **Buen patrón**: Strategy pattern con `SchedulingStrategy` trait (líneas 29-41). **Code Smell**: Línea 47-55 usa `unwrap_or(1.0)` para job weight - podría enmascarar errores de cálculo. **Bug**: Línea 136-148 en `bin_pack_workers()` tiene lógica de break que puede salir temprano del loop. **Mejora**: `calculate_priority()` (líneas 43-55) podría devolver `Result<f64>` en lugar de usar `unwrap_or`."
    },
    {
      "num": "38",
      "file": "crates/core/src/domain_services/queue_manager.rs",
      "layer": "Core Domain",
      "ddd_type": "Domain Service + Value Object + Strategy Pattern",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Domain Service con Strategy pattern para queueing policies. **Buen patrón**: `QueueingPolicy` trait (líneas 10-12) y `WFQPolicy` implementation (líneas 15-50). **Code Smell**: Línea 42 usa `unwrap_or(1.0)` para tenant weight - podría usar default weight configurable. **Bug**: Línea 129 actualiza `global_virtual_time` en cada dequeue sin considerar job weight. **Mejora**: `QueueStatus` (líneas 182-187) podría ser Value Object con métodos de validación."
    },
    {
      "num": "39",
      "file": "crates/core/src/domain_services/worker_matcher.rs",
      "layer": "Core Domain",
      "ddd_type": "Domain Service",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Domain Service complejo con múltiples criterios de matching. **Buen patrón**: Configurable strict/lenient modes (líneas 21-27). **Code Smell**: Línea 125 usa `partial_cmp().unwrap_or()` - podría causar panic si scores son NaN. **Bug**: Línea 107 en lenient mode acepta cualquier job con labels si worker también tiene labels, sin verificar compatibilidad. **Mejora**: `calculate_suitability_score()` (líneas 135-170) podría usar weights configurables en lugar de hardcoded (0.5, 0.3, 0.2)."
    },
    {
      "num": "41",
      "file": "crates/core/src/events.rs",
      "layer": "Core Domain",
      "ddd_type": "Infrastructure + Domain Service + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Comprehensive Event Sourcing infrastructure con traits bien definidos. **Buen patrón**: `EventRegistry` para deserialización dinámica de eventos (líneas 120-171). **Code Smell**: `load_events()` y `load_events_by_type()` devuelven listas vacías en lugar de implementar deserialización completa (líneas 319-323, 334-345, 571-581, 586-616). **Bug**: Línea 478 calcula `current_version = (row.0 + 1) as u64` pero debería ser `row.0 as u64` (versión actual, no siguiente). **Mejora**: `PostgreSqlEventStore::init()` (líneas 407-452) podría usar migraciones en lugar de CREATE TABLE IF NOT EXISTS."
    },
    {
      "num": "43",
      "file": "crates/core/src/job_definitions.rs",
      "layer": "Core Domain",
      "ddd_type": "Value Object + Builder Pattern + Domain Service",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Comprehensive Value Objects con validación robusta. **Buen patrón**: Builder pattern para `JobSpec` (líneas 182-252) con validación final. **Excelente patrón**: Property-based testing para state machine invariants (líneas 367-798). **Code Smell**: `JobId` (líneas 10-26) tiene campo público `pub Uuid` - viola encapsulación. **Bug**: Línea 324-325 y 329-331 usan `expect()` en conversiones `From<String>` y `From<&str>` - deberían devolver `Result`. **Mejora**: `parse_job_state()` (líneas 335-346) duplica lógica de `JobState::try_from_str()` (líneas 350-353)."
    },
    {
      "num": "44",
      "file": "crates/core/src/job.rs",
      "layer": "Core Domain",
      "ddd_type": "Entity + Aggregate Root",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Aggregate Root con encapsulación robusta y state machine. **Buen patrón**: `compare_and_swap_status()` (líneas 325-355) para transiciones atómicas concurrentes. **Excelente patrón**: Memory optimization con `JsonSize` trait (líneas 18-35) y `estimated_memory_size()` (líneas 375-403). **Code Smell**: `cloned_with_description()` (líneas 170-174) y `cloned_with_tenant()` (líneas 176-181) mutan clones - violan inmutabilidad del aggregate. **Bug**: Línea 172 y 179 usan `clone()` y luego mutan - deberían usar builder pattern. **Mejora**: `compare_and_swap_status_str()` (líneas 358-372) es deprecated pero sigue implementado."
    },
    {
      "num": "45",
      "file": "crates/core/src/job_specifications.rs",
      "layer": "Core Domain",
      "ddd_type": "Specification Pattern + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Specification Pattern bien implementado con composición (AND, OR, NOT). **Buen patrón**: `ValidJobSpec` (líneas 122-184) como composite specification. **Excelente patrón**: `validate_job_spec()` (líneas 187-215) y `validate_job_spec_composable()` (líneas 218-241) con detailed error reporting. **Code Smell**: `ValidJobSpec::composed()` (líneas 149-163) tiene type signature muy complejo - viola principio de simpleza. **Bug**: Línea 195-212 en `validate_job_spec()` valida individualmente cada spec pero `ValidJobSpec::with_all()` (líneas 140-145) ya hace composición AND. **Mejora**: `ValidJobSpec` podría implementar `Specification<JobSpec>` trait directamente en lugar de tener campos individuales."
    },
    {
      "num": "47",
      "file": "crates/core/src/mappers/job_mapper.rs",
      "layer": "Core Domain",
      "ddd_type": "Data Mapper + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Data Mapper pattern bien implementado para separar mapping logic de repositories. **Buen patrón**: `JobRow` (líneas 12-24) como Value Object para representación de base de datos. **Code Smell**: Línea 60 usa `unwrap_or(Value::Null)` para serialización de job spec - podría enmascarar errores de serialización. **Bug**: Línea 109 en `to_update_params()` usa `unwrap_or_else(|_| \"{}\".to_string())` para serialización de job spec - podría generar JSON inválido si falla serialización. **Mejora**: `to_update_params()` (líneas 93-141) genera SQL dinámico con placeholders - vulnerable a SQL injection si parámetros no son escapados correctamente."
    },
    {
      "num": "49",
      "file": "crates/core/src/mappers/worker_mapper.rs",
      "layer": "Core Domain",
      "ddd_type": "Data Mapper + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Data Mapper pattern bien implementado con soporte para serialización compleja. **Buen patrón**: `WorkerRow` (líneas 15-25) como Value Object para representación de base de datos. **Code Smell**: Línea 71 usa default capabilities `WorkerCapabilities::new(1, 1024)` si JSON es None - podría no reflejar capacidades reales del worker. **Bug**: Línea 81 en `from_row()` crea `last_heartbeat` con `chrono::Utc::now().into()` pero debería usar timestamp de la base de datos o campo específico. **Mejora**: `metadata` deserialization (líneas 92-96) usa múltiples `ok()` y `flatten()` - podría simplificarse con `and_then()` más directo."
    },
    {
      "num": "50",
      "file": "crates/core/src/pipeline_execution.rs",
      "layer": "Core Domain",
      "ddd_type": "Entity + Aggregate Root",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Aggregate Root complejo con state machine para orquestación de steps. **Buen patrón**: `PipelineExecutionStatus` enum (líneas 8-15) como Value Object para estados de ejecución. **Code Smell**: `start()` (líneas 172-180) y `complete_step()` (líneas 182-190) mutan el aggregate directamente - violan inmutabilidad del aggregate. **Bug**: Línea 155-160 en `execute_next_step()` no valida que el step actual esté completado antes de ejecutar el siguiente. **Mejora**: `PipelineExecution` podría usar Event Sourcing para tracking de cambios de estado."
    },
    {
      "num": "51",
      "file": "crates/core/src/pipeline.rs",
      "layer": "Core Domain",
      "ddd_type": "Entity + Aggregate Root",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Aggregate Root con validación compleja de DAG y topological sorting. **Buen patrón**: `PipelineStep` (líneas 53-120) como Entity con Builder Pattern para construcción segura. **Code Smell**: `has_cycle()` (líneas 155-170) implementa DFS recursivo - podría causar stack overflow en pipelines muy grandes. **Bug**: Línea 172-190 en `topological_sort()` usa algoritmo O(n²) - ineficiente para pipelines grandes. **Mejora**: `Pipeline` podría usar Graph trait para abstraer algoritmos de grafos."
    },
    {
      "num": "52",
      "file": "crates/core/src/pipeline_step_specifications.rs",
      "layer": "Core Domain",
      "ddd_type": "Specification Pattern + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Specification Pattern bien implementado con composición flexible. **Buen patrón**: `ValidPipelineStep` (líneas 122-184) como composite specification. **Excelente patrón**: `validate_pipeline_step()` (líneas 187-215) y `validate_pipeline_step_composable()` (líneas 218-241) con detailed error reporting. **Code Smell**: `ValidPipelineStep::composed()` (líneas 149-163) tiene type signature muy complejo - viola principio de simpleza. **Bug**: Línea 195-212 en `validate_pipeline_step()` valida individualmente cada spec pero `ValidPipelineStep::with_all()` (líneas 140-145) ya hace composición AND. **Mejora**: `ValidPipelineStep` podría implementar `Specification<PipelineStep>` trait directamente en lugar de tener campos individuales."
    },
    {
      "num": "53",
      "file": "crates/core/src/projections.rs",
      "layer": "Core Domain",
      "ddd_type": "Infrastructure + Domain Service + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Comprehensive Event Sourcing projections infrastructure. **Buen patrón**: `Projector` trait (líneas 19-26) y `ReadModel` trait (líneas 28-35) para abstracción. **Code Smell**: `JobStatusProjection::version()` (líneas 57-61) usa timestamp como versión - no garantiza monotonicidad. **Bug**: Línea 338-340 en `project()` procesa `tenant_id` pero no lo asigna a la projection. **Mejora**: `build_projections_from_events()` (líneas 391-415) solo carga eventos `JobCreated` - debería cargar todos los tipos de eventos relevantes."
    },
    {
      "num": "55",
      "file": "crates/core/src/security.rs",
      "layer": "Core Domain",
      "ddd_type": "Value Object + Entity + Legacy Pattern",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Value Objects (`RoleId`, `PermissionId`) con validación UUID. **Buen patrón**: `RoleEntity` (líneas 27-34) y `PermissionEntity` (líneas 36-43) como Entities con timestamps. **Code Smell**: `Role` y `Permission` enums (líneas 45-51, 53-59) duplican funcionalidad de `RoleEntity`/`PermissionEntity` - viola DRY. **Bug**: Línea 61-67 `SecurityContext` usa enums `Role` y `Permission` en lugar de `RoleId`/`PermissionId` - inconsistencia de tipos. **Mejora**: Eliminar enums `Role` y `Permission` y usar solo `RoleEntity`/`PermissionEntity` con `RoleId`/`PermissionId`."
    },
    {
      "num": "56",
      "file": "crates/core/src/specifications.rs",
      "layer": "Core Domain",
      "ddd_type": "Specification Pattern + Domain Service",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Specification Pattern bien implementado con composición flexible. **Buen patrón**: `Specification<T>` trait (líneas 9-11) con métodos `and()`, `or()`, `not()` para composición fluida. **Excelente patrón**: `AndSpec`, `OrSpec`, `NotSpec` como structs genéricos para composición type-safe. **Code Smell**: Línea 47-49 `is_satisfied_by()` tiene implementación default vacía - debería ser abstracto. **Bug**: `NotSpec` (líneas 37-45) no implementa `is_satisfied_by()` - viola contrato del trait. **Mejora**: Podría agregar métodos helper como `all_of()`, `any_of()`, `none_of()` para composición más expresiva."
    },
    {
      "num": "57",
      "file": "crates/core/src/tracing.rs",
      "layer": "Core Domain",
      "ddd_type": "Infrastructure + Domain Service",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Infrastructure utilities para distributed tracing. **Buen patrón**: `extract_context_from_headers()` (líneas 17-25) usa OpenTelemetry propagator para extraer contexto de headers HTTP. **Excelente patrón**: `create_span_with_attributes()` (líneas 27-35) crea spans con atributos para observabilidad. **Code Smell**: Línea 37-45 `propagate_error_context()` usa `global::get_text_map_propagator()` que es global mutable state - puede causar race conditions. **Bug**: No hay manejo de errores para headers mal formados en `extract_context_from_headers()`. **Mejora**: Podría usar `tracing` crate en lugar de OpenTelemetry directo para consistencia con el resto del códigobase."
    },
    {
      "num": "58",
      "file": "crates/core/src/worker_messages.rs",
      "layer": "Core Domain",
      "ddd_type": "Value Object + Domain Service",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Value Objects para worker communication. **Buen patrón**: `WorkerCapabilities` (líneas 25-43) como Value Object con parsing desde string. **Excelente patrón**: `from_string_list()` (líneas 45-55) parsea capabilities como \"cpu=4,memory=8192,gpu=1\" con validación. **Code Smell**: `WorkerState` (líneas 21-23) es enum con solo 3 estados - podría necesitar más granularidad (e.g., `Draining`, `Maintenance`, `Unhealthy`). **Bug**: Línea 53-55 en `from_string_list()` usa `trim().is_empty()` pero no valida formato de cada capability (debería ser \"key=value\"). **Mejora**: `WorkerId` (líneas 17-19) tiene campo público `pub Uuid` - viola encapsulación de Value Object."
    },
    {
      "num": "59",
      "file": "crates/core/src/worker.rs",
      "layer": "Core Domain",
      "ddd_type": "Entity + Aggregate Root",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Aggregate Root con encapsulación robusta y state management. **Buen patrón**: `is_available()` (líneas 51-53) valida capacidad y estado simultáneamente. **Excelente patrón**: `assign_job()` (líneas 55-57) y `complete_job()` (líneas 59-61) mantienen consistencia del aggregate. **Code Smell**: `WorkerStatus` (líneas 27-29) es enum con solo 3 estados - podría necesitar más granularidad (e.g., `Draining`, `Maintenance`, `Unhealthy`). **Bug**: Línea 43-45 en `new()` no valida que `capabilities.max_concurrent_jobs` sea mayor que 0. **Mejora**: `last_heartbeat` (línea 31) podría tener validación para asegurar que no es fecha futura."
    },
    {
      "num": "60",
      "file": "crates/hwp-agent/build.rs",
      "layer": "HWP Agent - tests",
      "ddd_type": "Build Script + Configuration",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Build script con optimizaciones de tamaño. **Buen patrón**: `cargo:rustc-link-arg=-s` (línea 15) para strip symbols y reducir binary size. **Excelente patrón**: `cargo:rustc-opt-level=z` (línea 16) para optimización máxima de tamaño. **Code Smell**: Línea 19-21 genera versión con `env!(\\\"CARGO_PKG_VERSION\\\")` pero no valida formato semver. **Bug**: No hay manejo de errores para flags de compilación inválidos. **Mejora**: Podría agregar conditional compilation para diferentes targets (Linux, Windows, macOS)."
    },
    {
      "num": "61",
      "file": "crates/hwp-agent/src/artifacts/compression.rs",
      "layer": "HWP Agent - src/",
      "ddd_type": "Value Object + Domain Service",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Value Object para compression configuration. **Buen patrón**: `CompressionType` enum (líneas 8-11) con `None` y `Gzip` variants. **Excelente patrón**: `Compressor::compress()` (líneas 26-45) con soporte para múltiples algoritmos. **Code Smell**: Línea 30-32 en `compress()` usa `GzEncoder::new(Vec::new(), Compression::default())` - `default()` compression puede no ser óptimo. **Bug**: No hay validación de tamaño máximo para datos de entrada - podría causar OOM. **Mejora**: `CompressionError` (líneas 13-24) podría tener variantes más específicas (e.g., `InputTooLarge`, `UnsupportedAlgorithm`)."
    },
    {
      "num": "63",
      "file": "crates/hwp-agent/src/artifacts/resume_manager.rs",
      "layer": "HWP Agent - src/",
      "ddd_type": "Domain Service + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Domain Service para gestión de resumen de uploads. **Buen patrón**: `UploadSession` (líneas 16-35) como Value Object para tracking de estado de upload. **Excelente patrón**: `get_missing_chunks()` (líneas 130-150) detecta chunks faltantes eficientemente. **Code Smell**: `resume_upload()` (líneas 153-189) acepta parámetro `_uploader: ArtifactUploader` pero no lo usa - viola interfaz. **Bug**: Línea 176-179 tiene TODO comentario sobre implementación real pero la función actualmente solo marca sesión como completa sin realmente re-subir chunks faltantes. **Mejora**: `cleanup_old_sessions()` (líneas 230-236) no implementa limpieza real - solo retorna count de sesiones activas."
    },
    {
      "num": "64",
      "file": "crates/hwp-agent/src/artifacts/text_replacer.rs",
      "layer": "HWP Agent - src/",
      "ddd_type": "Domain Service + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Domain Service para text replacement eficiente. **Buen patrón**: `TextReplacer` (líneas 8-15) como Value Object con configuración. **Excelente patrón**: `preserve_case()` (líneas 144-190) mantiene capitalización original del texto durante reemplazo. **Code Smell**: Línea 23 usa `unwrap_or_else` con fallback hardcoded `[(\\\"password\\\", \\\"***\\\")]` - debería fallar explícitamente si patterns son inválidos. **Bug**: Línea 23 - si `AhoCorasick::new(&config.patterns)` falla, usa fallback silenciosamente. **Mejora**: `replace_text()` (líneas 29-31) no valida tamaño máximo de texto de entrada - podría causar OOM con textos muy grandes."
    },
    {
      "num": "65",
      "file": "crates/hwp-agent/src/artifacts/uploader.rs",
      "layer": "HWP Agent - src/",
      "ddd_type": "Domain Service + Value Object + Adapter",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Domain Service para upload de artifacts con streaming gRPC. **Buen patrón**: `ArtifactUploader` (líneas 8-15) como Value Object con configuración. **Excelente patrón**: Streaming gRPC con chunking (líneas 155-179) para archivos grandes. **Code Smell**: Línea 99 usa `unwrap_or(1024 * 1024)` para chunk size - debería usar configuración. **Bug**: Línea 187-191 calcula checksum pero no lo valida contra el servidor. **Mejora**: `upload_artifact()` (líneas 94-99) no maneja reconexión si falla el streaming gRPC."
    },
    {
      "num": "66",
      "file": "crates/hwp-agent/src/config.rs",
      "layer": "HWP Agent - src/",
      "ddd_type": "Value Object + Domain Service",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Value Object para configuración del agente. **Buen patrón**: `AgentConfig` (líneas 8-35) como Value Object con validación. **Excelente patrón**: `from_env()` (líneas 144-152) carga configuración desde variables de entorno con validación. **Code Smell**: Línea 171-175 usa `max(1024)` para buffer size - debería ser configurable. **Bug**: Línea 176-180 no valida que `heartbeat_interval_ms` sea mayor que 0. **Mejora**: `AgentConfig` podría implementar `Default` trait con valores sensibles para testing."
    },
    {
      "num": "67",
      "file": "crates/hwp-agent/src/connection/auth.rs",
      "layer": "HWP Agent - src/",
      "ddd_type": "Adapter + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Adapter pattern para autenticación gRPC. **Buen patrón**: `AuthInterceptor` (líneas 8-15) como Value Object con configuración. **Excelente patrón**: Implementación de `Interceptor` trait (líneas 51-66) para agregar headers de autorización. **Code Smell**: Línea 32-42 usa `unwrap_or_default()` para token validation - podría enmascarar errores de parsing. **Bug**: Línea 44-48 no valida formato de timestamp en token JWT. **Mejora**: `AuthInterceptor` podría cachear tokens para evitar validación repetida."
    },
    {
      "num": "68",
      "file": "crates/hwp-agent/src/connection/grpc_client.rs",
      "layer": "HWP Agent - src/",
      "ddd_type": "Adapter + Value Object + Domain Service",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Comprehensive gRPC client con soporte para TLS/mTLS y bidirectional streaming. **Buen patrón**: `ClientConfig` (líneas 8-55) como Value Object con validación de configuración. **Excelente patrón**: `Client::connect()` (líneas 114-205) maneja reconexión automática y bidirectional streaming. **Code Smell**: Línea 315-469 en `execute_job()` usa múltiples `unwrap()` - podría causar panic en producción. **Bug**: Línea 522-575 en `allocate_pty()` no valida que el proceso hijo exista antes de asignar PTY. **Mejora**: `Client::new()` (líneas 57-112) podría usar builder pattern para configuración más flexible."
    },
    {
      "num": "71",
      "file": "crates/hwp-agent/src/executor/process.rs",
      "layer": "HWP Agent - src/",
      "ddd_type": "Domain Service + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Domain Service para gestión de procesos del sistema. **Buen patrón**: `ProcessInfo` (líneas 15-25) como Value Object para tracking de estado de proceso. **Excelente patrón**: `JobExecutor` (líneas 27-89) con métodos `spawn_job()`, `cancel_job()`, `cleanup_finished()`. **Code Smell**: Línea 95-96 usa `unwrap_or_default()` para `env` y `cwd` - podría usar valores por defecto más seguros. **Bug**: Línea 168-178 en `cancel_job()` no valida que el job esté realmente corriendo antes de intentar matarlo. **Mejora**: `spawn_job()` (líneas 91-148) podría devolver `Result<JobHandle>` en lugar de usar `expect()` en línea 147."
    },
    {
      "num": "72",
      "file": "crates/hwp-agent/src/executor/pty.rs",
      "layer": "HWP Agent - src/",
      "ddd_type": "Value Object + Domain Service",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Value Objects para configuración de PTY. **Buen patrón**: `PtySizeConfig` (líneas 20-26) como Value Object con defaults sensibles (80x24). **Excelente patrón**: `PtyAllocation` (líneas 52-67) como Value Object para resultado de asignación de PTY. **Code Smell**: `PtyMaster` (líneas 39-50) tiene implementación simplificada con `todo!()` - no es funcional en producción. **Bug**: Línea 49-50 en `PtyMaster::new()` usa `todo!()` - viola principio de implementaciones completas. **Mejora**: `PtyMaster` debería usar crate como `nix` o `libc` para implementación real de PTY. **Sospechoso**: `PtyMaster` (líneas 39-50) es struct con campos públicos - viola encapsulación de Value Object."
    },
    {
      "num": "73",
      "file": "crates/hwp-agent/src/lib.rs",
      "layer": "HWP Agent - src/",
      "ddd_type": "Module Export + Value Object (Error Types)",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Centralized exports para todo el HWP Agent. **Buen patrón**: `AgentError` enum (líneas 31-56) como Value Object con granular categorías de error. **Excelente patrón**: `From` implementations para conversión entre error types (líneas 58-62). **Code Smell**: Línea 14-25 exporta módulos pero no documenta qué funcionalidad proporciona cada uno. **Bug**: Línea 31-56 `AgentError` tiene variante `Other(String)` que puede enmascarar errores específicos. **Mejora**: Podría agregar métodos helper para crear errores específicos (e.g., `AgentError::connection_error()`, `AgentError::execution_error()`)."
    },
    {
      "num": "74",
      "file": "crates/hwp-agent/src/monitor/resources.rs",
      "layer": "HWP Agent - src/",
      "ddd_type": "Domain Service + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Domain Service para monitoreo de recursos del sistema. **Buen patrón**: `ResourceUsage` (líneas 12-21) como Value Object con métricas de recursos. **Excelente patrón**: `ResourceMonitor::monitor_pids()` (líneas 98-122) con streaming continuo de métricas. **Code Smell**: Línea 77-80 tiene valores hardcoded 0 para disk/network I/O porque sysinfo v0.30 no soporta per-process - debería documentarse. **Bug**: Línea 57 usa `unwrap()` en lock acquisition - podría causar panic si el mutex está poisoned. **Mejora**: `get_usage()` (líneas 56-95) devuelve `Result<ResourceUsage, String>` - debería usar tipo de error específico en lugar de `String`."
    },
    {
      "num": "75",
      "file": "crates/hwp-proto/build.rs",
      "layer": "HWP Proto",
      "ddd_type": "Build Script",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Build script simple y directo para generación de código gRPC. **Buen patrón**: Usa `tonic_prost_build::compile_protos()` (línea 4) que genera tanto tipos de mensajes como código de servicio gRPC. **Excelente patrón**: Error handling con `Result<(), Box<dyn std::error::Error>>` (línea 1) y `?` operator (línea 4). **Code Smell**: No hay configuración personalizada para `tonic_prost_build` - usa defaults que pueden no ser óptimos. **Bug**: No hay validación de que el archivo `protos/hwp.proto` exista antes de compilar. **Mejora**: Podría agregar configuración como `service_generator`, `out_dir`, o `compile_well_known_types`."
    },
    {
      "num": "76",
      "file": "crates/hwp-proto/src/lib.rs",
      "layer": "HWP Proto",
      "ddd_type": "Module Export + Value Object (Protocol Types)",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Simple module export para tipos de protocolo gRPC. **Buen patrón**: `pub mod pb { tonic::include_proto!(\"hwp\"); }` (líneas 6-8) para incluir código generado. **Excelente patrón**: Re-export de tipos importantes (líneas 10-36) y client/server types (líneas 38-39). **Code Smell**: No hay documentación sobre qué mensajes contiene el protocolo y su propósito. **Bug**: Línea 42-43 re-exporta `Payload` types pero no documenta las variantes disponibles. **Mejora**: Podría agregar documentación sobre el protocolo HWP y ejemplos de uso."
    },
    {
      "num": "77",
      "file": "crates/modules/src/artifact_management.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Value Object + Repository Pattern",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Comprehensive Domain Service con Repository Pattern y Storage Provider abstraction. **Buen patrón**: `ArtifactRepository` y `StorageProvider` traits (líneas 105-158) para separación de concerns. **Excelente patrón**: `ArtifactManagementService` con caching de active uploads (líneas 217-227) y validación robusta. **Code Smell**: Línea 302-303 convierte cualquier error a `StorageError::Io` - pierde información del error original. **Bug**: Línea 344-345 usa `ok_or_else` con mensaje genérico \"Upload not found\" - debería usar error type específico. **Mejora**: `ArtifactError` (líneas 162-180) podría tener variantes más específicas para diferentes casos de error."
    },
    {
      "num": "78",
      "file": "crates/modules/src/auto_scaling_engine.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Value Object + Strategy Pattern",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Comprehensive Domain Service con Strategy Pattern para auto-scaling. **Buen patrón**: `AutoScalingPolicy` con `ScalingTrigger` y `ScalingStrategy` (líneas 16-112). **Excelente patrón**: `PredictionEngine` con linear regression y anomaly detection (líneas 229-337). **Code Smell**: Línea 256-258 usa `drain(0..metrics.len() - 1000)` que es O(n) - podría usar `truncate` con offset. **Bug**: Línea 447-449 convierte `Duration` a `chrono::Duration` con `unwrap_or_default` - podría causar overflow. **Mejora**: `evaluate_triggers()` (líneas 458-559) podría usar pattern matching más expresivo con guards."
    },
    {
      "num": "79",
      "file": "crates/modules/src/burst_capacity_manager.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Value Object",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Domain Service para gestión de burst capacity con multi-tenancy. **Buen patrón**: `BurstCapacityConfig` (líneas 16-26) como Value Object con defaults sensibles. **Excelente patrón**: `BurstSession` tracking con cost accrual (líneas 29-38) y `BurstStats` (líneas 69-78). **Code Smell**: Línea 169-178 usa `if let Ok(cooldown) && elapsed < cooldown` - podría separar para mejor legibilidad. **Bug**: Línea 182-184 valida `cpu_cores * multiplier > 1000` pero el mensaje de error es `MaxBurstDurationExceeded` - inconsistencia. **Mejora**: `determine_burst_multiplier()` (líneas 328-341) tiene parámetros `_request` y `_usage` no usados - viola principio de mínima sorpresa."
    },
    {
      "num": "80",
      "file": "crates/modules/src/cooldown_management.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Value Object + Strategy Pattern",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Domain Service con Strategy Pattern para gestión avanzada de cooldowns. **Buen patrón**: `CooldownType` enum (líneas 17-22) y `OverrideReason` enum (líneas 40-47) como Value Objects. **Excelente patrón**: `AdvancedCooldownManager` con rate limiting de overrides (líneas 236-245) y cleanup automático (líneas 342-351). **Code Smell**: Línea 361-365 usa `if let Some(expiry) && Utc::now() < expiry` - podría separar para mejor legibilidad. **Bug**: Línea 248 usa `chrono::Duration::minutes(5)` hardcoded para override expiry - debería ser configurable. **Mejora**: `check_cooldown_state()` (líneas 354-385) podría usar pattern matching más expresivo."
    },
    {
      "num": "81",
      "file": "crates/modules/src/cost_optimization.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Value Object + Report Pattern",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Domain Service para análisis de costos y optimización. **Buen patrón**: `OptimizationRecommendation` enum (líneas 11-52) como Value Object con variantes específicas. **Excelente patrón**: `OptimizationReport` (líneas 103-115) como Value Object con datos estructurados. **Code Smell**: Líneas 172-224 generan datos de muestra hardcoded - viola principio de implementaciones reales. **Bug**: `generate_report()` (líneas 167-225) siempre devuelve los mismos datos de muestra - no realiza análisis real. **Mejora**: `CostOptimizationEngine` (líneas 118-122) tiene campos `_cost_history` y `_utilization_history` pero no los usa realmente."
    },
    {
      "num": "82",
      "file": "crates/modules/src/cost_tracking.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Value Object + Repository Pattern",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Domain Service con Repository Pattern para tracking de costos. **Buen patrón**: `WorkerCost` (líneas 17-66) como Value Object con cálculo de costos por recurso. **Excelente patrón**: `CostTrackingService` con DashMap para concurrent access (líneas 217-223) y `CostAlerts` para alertas (líneas 401-457). **Code Smell**: Línea 120 usa `unwrap_or_default()` para conversión de duración - podría causar errores silenciosos. **Bug**: Línea 199 calcula `average_cost_per_job_cents` con división entera - puede causar truncamiento. **Mejora**: `CostSummary::add_job_cost()` (líneas 176-200) podría validar que `total_jobs > 0` antes de calcular promedio."
    },
    {
      "num": "84",
      "file": "crates/modules/src/log_persistence.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Adapter",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Domain Service con patrón Event-Driven Architecture. **Buen patrón**: `LogPersistenceService` como background service con event subscription. **Code Smell**: Línea 57-58 tiene comentario \"No-op: We don't persist chunks anymore\" pero el método `handle_log_entry()` (líneas 146-171) sigue implementado - dead code. **Bug**: Línea 60-72 procesa `JobCompleted` pero no valida que `compressed_logs` sea `Some` antes de usar `logs` - podría causar panic. **Mejora**: `start()` (líneas 38-87) no maneja graceful shutdown del background task."
    },
    {
      "num": "85",
      "file": "crates/modules/src/metrics_collection.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Value Object + Repository Pattern",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Comprehensive Domain Service con Value Objects para métricas. **Buen patrón**: `MetricType` enum (líneas 15-34) como Value Object con variantes específicas. **Excelente patrón**: `percentile()` function (líneas 288-304) con interpolación lineal para cálculos precisos. **Code Smell**: `MetricsCollector` (líneas 86-91) tiene campos `_config`, `_aggregation_engine` con underscore - indican no uso. **Bug**: Línea 239 usa `partial_cmp().unwrap()` en `sorted_values.sort_by()` - podría causar panic si hay NaN values. **Mejora**: `MetricsStore::get_latest_snapshot()` (líneas 187-208) solo devuelve el valor más reciente por tipo de métrica - podría devolver todos los valores actuales."
    },
    {
      "num": "86",
      "file": "crates/modules/src/multi_tenancy_quota_manager.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Value Object + Policy Pattern",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Comprehensive Domain Service con Policy Pattern para gestión de quotas multi-tenant. **Buen patrón**: `QuotaType` enum (líneas 63-68) y `BillingTier` enum (líneas 54-60) como Value Objects. **Excelente patrón**: `QuotaDecision` enum (líneas 156-168) con variantes `Allow`, `Deny`, `Queue` para decisiones granulares. **Code Smell**: Línea 380-404 valida soft limits pero solo para CPU - debería validar también memory y workers. **Bug**: Línea 573-576 convierte `Duration` a `chrono::Duration` con `if let Ok(cooldown_duration)` pero no maneja error de conversión. **Mejora**: `calculate_cost()` (líneas 607-628) usa precios hardcoded - debería ser configurable."
    },
    {
      "num": "87",
      "file": "crates/modules/src/orchestrator.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Adapter + Factory Pattern",
      "text": "BUG identificado",
      "full_comment": "**Buen diseño**: Domain Service con Factory Pattern para creación de jobs y pipelines. **Buen patrón**: `OrchestratorModule` como facade para operaciones de orquestación. **Excelente patrón**: Event publishing después de cada operación (líneas 60-63, 112-115, 139-144). **Code Smell**: Líneas 52, 58, 63, 72, 82, 87, 92, 105, 110, 115, 127, 132, 137, 144 convierten todos los errores a `OrchestratorError::DomainError` - pierde información específica del error. **Bug**: Línea 85-87 usa `let mut job = job; job.cancel()` pero `job` ya es mutable desde línea 85 - duplicación. **Mejora**: `OrchestratorError` (líneas 166-188) tiene variantes `JobRepository` y `PipelineRepository` pero no se usan - viola principio de mínima sorpresa."
    },
    {
      "num": "88",
      "file": "crates/modules/src/pipeline_crud.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Value Object + Application Service",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Comprehensive Application Service con CRUD completo y validación robusta. **Buen patrón**: `PipelineCrudConfig` (líneas 21-36) como Value Object con defaults sensibles. **Excelente patrón**: Builder Pattern para creación de steps (líneas 490-532) y validación de DAG. **Code Smell**: Líneas 110, 116, 122, 135, 184, 237, 256, 277, 296, 341, 376, 410, 416 convierten todos los errores a `PipelineCrudError::DomainError` - pierde información específica del error. **Bug**: Línea 227-231 valida DAG creando un nuevo pipeline con `Pipeline::new()` pero no usa el resultado - podría usar `Pipeline::validate_dag()` si existe. **Mejora**: `create_pipeline_step()` (líneas 490-532) podría usar `PipelineStepBuilder` directamente en lugar de crear `JobSpec` manualmente."
    },
    {
      "num": "89",
      "file": "crates/modules/src/pipeline_execution_orchestrator.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Adapter + Strategy Pattern + Factory Pattern",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Comprehensive Domain Service con Strategy Pattern para orquestación compleja. **Buen patrón**: `PipelineExecutionConfig` (líneas 29-46) como Value Object con defaults. **Excelente patrón**: Cancellation channel pattern con `mpsc::unbounded_channel()` (líneas 103-104) y semaphore para concurrencia (línea 113). **Code Smell**: Línea 343 usa `step_semaphore.acquire().await.unwrap()` - podría manejar error de adquisición. **Bug**: Línea 372-373 en `execute_step()` trata `StepExecutionStatus::RUNNING` como completado - viola semántica del estado. **Mejora**: `execute_pipeline_async()` (líneas 257-437) tiene lógica muy compleja con múltiples niveles de anidación - podría dividirse en funciones más pequeñas."
    },
    {
      "num": "90",
      "file": "crates/modules/src/pool_lifecycle.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Value Object + State Pattern + Observer Pattern",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Domain Service con State Pattern para lifecycle management. **Buen patrón**: `PoolLifecycleState` enum (líneas 20-29) como Value Object con state machine. **Excelente patrón**: Observer Pattern con `PoolEventHandler` trait (líneas 663-665) y `LoggingEventHandler` (líneas 668-704). **Code Smell**: `PoolConfig::from_str()` (líneas 75-93) crea config default para cualquier string - viola principio de mínima sorpresa. **Bug**: Línea 577-588 en `health_check_all()` parsea `health.pool_id` como `PoolConfig` con `unwrap_or_else` - podría generar config inválida. **Mejora**: `MockResourcePool` (líneas 239-318) es solo para testing - debería estar en módulo de tests."
    },
    {
      "num": "91",
      "file": "crates/modules/src/queue_assignment.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Value Object + Strategy Pattern + Repository Pattern",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Comprehensive Domain Service con Strategy Pattern para scheduling policies. **Buen patrón**: `QueuePriority` enum (líneas 36-42) y `QueueType` enum (líneas 45-52) como Value Objects. **Excelente patrón**: Dead letter queue pattern con `DeadLetterQueue` (líneas 753-787) y timeout monitoring (líneas 918-937). **Code Smell**: `QueueMetrics` (líneas 119-126) usa `AtomicU64` pero `Clone` implementation (líneas 128-156) copia valores - podría causar inconsistencias. **Bug**: Línea 704-705 en `process_queues()` re-enquea job si no hay worker disponible pero rompe el loop - podría causar starvation. **Mejora**: `ResourcePool` trait (líneas 364-369) tiene solo 3 métodos - podría necesitar más operaciones para gestión completa de pools."
    },
    {
      "num": "92",
      "file": "crates/modules/src/queue_prioritization.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service + Value Objects + Strategy Pattern",
      "text": "BUG identificado",
      "full_comment": "**Excelente diseño**: Domain Service con Strategy Pattern para diferentes políticas de priorización. **Buen patrón**: Enums `PrioritizationStrategy` y `PreemptionPolicy` como Value Objects con variantes claras. **Code Smell**: `calculate_priority_score` (líneas 184-226) tiene pesos hardcoded - deberían ser configurables. **Bug**: Línea 233 en `calculate_fairness_score` devuelve 1.0 para nuevos tenants, pero esto podría dar ventaja injusta. **Mejora**: `execute_preemption` (líneas 346-375) recrea toda la queue en lugar de eliminar el elemento específico - ineficiente para colas grandes. **Inconsistencia**: `PrioritizationStats` (líneas 377-406) tiene campos `preemptions_requested` y `preemptions_executed` pero siempre devuelve 0."
    },
    {
      "num": "95",
      "file": "crates/modules/src/rbac.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Application Service",
      "text": "BUG identificado",
      "full_comment": "**Code Smells**: Event bus no utilizado (declarado pero no usado en métodos). Clonación manual del servicio (línea 378-392) - podría usar derive(Clone). Mapeo de errores repetitivo. **Mejoras**: Implementar uso real de event bus para publicar eventos de dominio. Usar derive(Clone) con atributos. Centralizar mapeo de errores con macros o helpers. Añadir validación de invariantes en DTOs (CreateRoleRequest, etc.). **Bugs**: Ninguno crítico identificado, pero falta validación de descripción length."
    },
    {
      "num": "101",
      "file": "crates/modules/src/scheduler/state_machine.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Application Service (State Machine)",
      "text": "BUG identificado",
      "full_comment": "**Code Smells**: Métodos genéricos con muchos constraints (R, E, W, WR) repetidos. Optimize state es placeholder (líneas 153-154). Error messages genéricos \"No eligible workers found\" (líneas 202, 207). **Bugs**: Ninguno evidente. **Mejoras**: Extraer constraints a trait. Implementar optimización real. Mejorar mensajes de error."
    },
    {
      "num": "102",
      "file": "crates/modules/src/security_management.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Application Service (CRUD Operations)",
      "text": "BUG identificado",
      "full_comment": "**Code Smells**: Método to_response tiene lógica compleja de permisos (líneas 568-621). Duplicación de validación UUID en múltiples métodos. Conversiones de error repetitivas. **Bugs**: Línea 201: error conversion sin .to_string(). Línea 290: error conversion sin .to_string(). **Mejoras**: Extraer lógica de permisos a Domain Service. Crear validador reutilizable para UUID. Usar Result<> en lugar de StdResult<>."
    },
    {
      "num": "103",
      "file": "crates/modules/src/sla_tracking.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service (SLA Tracking)",
      "text": "BUG identificado",
      "full_comment": "**Code Smells**: Método get_metrics tiene lógica duplicada con get_stats (líneas 372-414). Uso de unwrap_or_default en conversiones de tiempo (líneas 239, 275). queue_position no se usa en register_job (parámetro _queue_position). **Bugs**: Línea 379: violated_count siempre 0 (debería calcularse). Línea 393: time_remaining puede ser negativo si deadline pasado. **Mejoras**: Unificar get_stats y get_metrics. Validar thresholds en constructor. Manejar time_remaining negativo."
    },
    {
      "num": "104",
      "file": "crates/modules/src/weighted_fair_queuing.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Domain Service (WFQ Algorithm)",
      "text": "BUG identificado",
      "full_comment": "**Code Smells**: Método detect_and_handle_starvation mutable (&mut self) pero no necesita serlo (línea 423). Cálculo de packet_size simplificado (líneas 554-559). Estrategia Custom siempre retorna 2.0 (línea 513). **Bugs**: Línea 231: global_time se adquiere como write lock pero solo se lee. Línea 436: weight_config.weight se actualiza sin verificar existencia. **Mejoras**: Hacer detect_and_handle_starvation inmutable. Mejorar cálculo de packet_size. Implementar estrategia Custom real."
    },
    {
      "num": "105",
      "file": "crates/modules/src/worker_management.rs",
      "layer": "Modules (Application)",
      "ddd_type": "Application Service (Worker Lifecycle)",
      "text": "BUG identificado",
      "full_comment": "**Code Smells**: Archivo muy largo (3267 líneas) - debería dividirse. Muchos structs y enums anidados. Duplicación entre StaticPoolManager y DynamicPoolManager. Mock implementations inline (líneas 2490-2543). **Bugs**: Línea 893: disconnected_count siempre 0. Líneas 1183-1187: is_worker_reachable siempre retorna false. Líneas 1918-1921: check_worker_health siempre retorna true. **Mejoras**: Dividir en módulos separados. Extraer traits comunes. Implementar health checks reales. Remover mock implementations."
    }
  ]
}