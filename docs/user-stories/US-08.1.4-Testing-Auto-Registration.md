# User Story US-08.1.4: Testing Auto-Registration Flow

## ðŸ“‹ Story Information

- **Story ID**: US-08.1.4
- **Epic**: EPIC-08 - Resource Pool Architecture Implementation
- **Sub-EPIC**: 08.1 - Auto-Registration System
- **Priority**: High
- **Estimated Effort**: 2 days
- **Dependencies**: US-08.1.3 (Wiring Dependencies Between Services)
- **Assigned To**: Core Platform Team

---

## ðŸŽ¯ Story Description

As a **QA Engineer**, I want to **comprehensive test coverage for the auto-registration flow** so that **the system correctly registers workers with the scheduler under all scenarios, including failure cases**.

---

## ðŸ“– Context

Testing the auto-registration flow requires:
1. Unit tests for individual components (SchedulerPort, WorkerRegistrationAdapter)
2. Integration tests for the full flow (WorkerManagementService â†’ Scheduler)
3. Contract tests for gRPC interfaces
4. Failure scenario tests (network errors, timeouts, partial failures)
5. Performance tests for concurrent registration

---

## âœ… Acceptance Criteria

### AC-1: Unit Test Coverage
- [ ] SchedulerPort interface tests: 100% coverage
- [ ] WorkerRegistrationAdapter tests: 100% coverage
- [ ] All error types tested (network, timeout, validation)
- [ ] Retry logic tested with backoff calculation
- [ ] Metrics collection tested

### AC-2: Integration Test Coverage
- [ ] End-to-end flow: provision â†’ register â†’ available
- [ ] Batch worker registration tested
- [ ] Static and dynamic worker registration tested
- [ ] Concurrent registration (50+ workers) tested
- [ ] Worker lifecycle: provision â†’ register â†’ unregister â†’ cleanup

### AC-3: Failure Scenario Testing
- [ ] Scheduler unavailable during registration
- [ ] Network timeout during registration
- [ ] Partial batch registration failures
- [ ] Invalid worker data rejected
- [ ] Scheduler crash during registration
- [ ] Retries exhaust without success

### AC-4: Contract Tests
- [ ] gRPC interface contract validated
- [ ] Protocol buffer schema compatibility
- [ ] Error code mapping verified
- [ ] Timeout behavior verified
- [ ] Bidirectional streaming tested

### AC-5: Performance & Load Testing
- [ ] Registration throughput: > 100 workers/second
- [ ] Registration latency: < 2s (p95)
- [ ] Concurrent registration: 500 workers without degradation
- [ ] Resource usage under load: CPU < 80%, Memory stable
- [ ] No memory leaks during prolonged operation

### AC-6: Observability Testing
- [ ] Metrics exposed and correct
- [ ] Logs generated with proper context
- [ ] Trace propagation through the flow
- [ ] Dashboard metrics validation
- [ ] Alert rules triggered appropriately

---

## ðŸ› ï¸ Test Implementation

### Integration Test Suite

Location: `tests/integration/test_auto_registration.rs`

```rust
use hodei_modules::worker_management::WorkerManagementService;
use hodei_adapters::worker_registration::WorkerRegistrationAdapter;
use hodei_ports::worker_provider::WorkerProvider;

#[tokio::test]
async fn test_end_to_end_auto_registration() {
    // Setup embedded scheduler (test double)
    let scheduler = EmbeddedScheduler::new().await.unwrap();
    let scheduler_port = SchedulerPortClient::new(scheduler.channel());

    // Setup worker provider
    let provider = DockerWorkerProvider::new(DockerWorkerConfig::default());

    // Setup registration adapter with test config
    let registration_config = RegistrationConfig {
        max_retries: 2,
        registration_timeout: Duration::from_secs(5),
        ..Default::default()
    };
    let registration_adapter = WorkerRegistrationAdapter::new(
        scheduler_port,
        registration_config,
    );

    // Wire service with registration
    let management_config = WorkerManagementConfig::default();
    let service = WorkerManagementService::new_with_registration(
        provider,
        registration_adapter,
        management_config,
    );

    // Provision worker
    let config = DynamicWorkerConfig::builder()
        .worker_type(WorkerType::Docker)
        .cpu_cores(4)
        .memory_mb(8192)
        .build()
        .unwrap();

    let result = service.provision_worker(&config).await;

    assert!(result.is_ok());
    let provisioned = result.unwrap();
    assert_eq!(provisioned.status, WorkerStatus::Registered);

    // Verify worker is registered in scheduler
    let worker_info = scheduler.get_worker(&provisioned.worker_id).await.unwrap();
    assert!(worker_info.is_some());
    assert_eq!(worker_info.unwrap().status, WorkerStatus::Available);
}

#[tokio::test]
async fn test_concurrent_registration() {
    // Setup
    let scheduler = EmbeddedScheduler::new().await.unwrap();
    let scheduler_port = SchedulerPortClient::new(scheduler.channel());
    let registration_adapter = WorkerRegistrationAdapter::new(
        scheduler_port,
        RegistrationConfig::default(),
    );

    // Create 100 test workers
    let mut workers = Vec::new();
    for i in 0..100 {
        let worker = DynamicWorker::new(
            &format!("worker-{}", i),
            WorkerType::Docker,
            DynamicWorkerConfig::default(),
        );
        workers.push(worker);
    }

    // Register in batch
    let start = Instant::now();
    let results = registration_adapter.register_workers_batch(workers).await;
    let duration = start.elapsed();

    // Verify results
    assert_eq!(results.len(), 100);
    let success_count = results.iter().filter(|r| r.is_ok()).count();
    assert_eq!(success_count, 100);

    // Verify performance
    assert!(duration < Duration::from_secs(10), "Batch registration took too long");
}

#[tokio::test]
async fn test_registration_retry_on_failure() {
    // Setup scheduler that fails first 2 attempts, succeeds on 3rd
    let scheduler = FailingScheduler::new(2).await.unwrap();
    let scheduler_port = SchedulerPortClient::new(scheduler.channel());

    let registration_adapter = WorkerRegistrationAdapter::new(
        scheduler_port,
        RegistrationConfig {
            max_retries: 3,
            ..Default::default()
        },
    );

    let worker = create_test_worker();
    let start = Instant::now();
    let result = registration_adapter.register_worker(&worker).await;
    let duration = start.elapsed();

    assert!(result.is_ok());
    // Verify backoff delays occurred
    assert!(duration >= Duration::from_millis(300)); // 100ms + 200ms
}

#[tokio::test]
async fn test_registration_max_retries_exceeded() {
    // Setup scheduler that always fails
    let scheduler = FailingScheduler::new(100).await.unwrap();
    let scheduler_port = SchedulerPortClient::new(scheduler.channel());

    let registration_adapter = WorkerRegistrationAdapter::new(
        scheduler_port,
        RegistrationConfig {
            max_retries: 3,
            ..Default::default()
        },
    );

    let worker = create_test_worker();
    let result = registration_adapter.register_worker(&worker).await;

    assert!(result.is_err());
    assert!(matches!(
        result.unwrap_err(),
        RegistrationError::MaxRetriesExceeded { .. }
    ));
}

#[tokio::test]
async fn test_unregister_worker() {
    let scheduler = EmbeddedScheduler::new().await.unwrap();
    let scheduler_port = SchedulerPortClient::new(scheduler.channel());

    // Pre-register worker
    scheduler.add_worker(create_test_worker()).await;

    let registration_adapter = WorkerRegistrationAdapter::new(
        scheduler_port,
        RegistrationConfig::default(),
    );

    let result = registration_adapter.unregister_worker("test-worker").await;

    assert!(result.is_ok());

    // Verify worker is no longer available
    let worker_info = scheduler.get_worker("test-worker").await.unwrap();
    assert!(worker_info.is_none());
}
```

### Contract Test Suite

```rust
#[tokio::test]
async fn test_scheduler_contract() {
    // Test the gRPC contract between adapter and scheduler
    let scheduler = EmbeddedScheduler::new().await.unwrap();
    let mut client = SchedulerPortClient::new(scheduler.channel());

    // Test register_worker contract
    let request = RegisterWorkerRequest {
        worker_id: "contract-test-worker".to_string(),
        capabilities: Some(WorkerCapabilities {
            cpu_cores: 4,
            memory_mb: 8192,
            ..Default::default()
        }),
        metadata: Some(WorkerMetadata {
            worker_type: "docker".to_string(),
            labels: HashMap::new(),
            ..Default::default()
        }),
    };

    let response = client.register_worker(request).await.unwrap();

    assert_eq!(response.status, RegistrationStatus::Success);

    // Test unregister_worker contract
    let unregister_request = UnregisterWorkerRequest {
        worker_id: "contract-test-worker".to_string(),
    };

    let unregister_response = client.unregister_worker(unregister_request).await.unwrap();
    assert_eq!(unregister_response.status, UnregistrationStatus::Success);
}

#[tokio::test]
async fn test_error_handling_contract() {
    let scheduler = EmbeddedScheduler::new().await.unwrap();
    let mut client = SchedulerPortClient::new(scheduler.channel());

    // Test error code mapping
    let request = RegisterWorkerRequest {
        worker_id: "".to_string(), // Invalid - empty ID
        capabilities: None,
        metadata: None,
    };

    let response = client.register_worker(request).await;

    assert!(response.is_err());
    let status = response.unwrap_err();
    assert_eq!(status.code(), tonic::Code::InvalidArgument);
}
```

### Performance Test Suite

```rust
#[tokio::test]
async fn test_registration_throughput() {
    let scheduler = EmbeddedScheduler::new().await.unwrap();
    let scheduler_port = SchedulerPortClient::new(scheduler.channel());

    let registration_adapter = WorkerRegistrationAdapter::new(
        scheduler_port,
        RegistrationConfig::default(),
    );

    // Warmup
    for _ in 0..10 {
        let worker = create_test_worker();
        let _ = registration_adapter.register_worker(&worker).await;
    }

    // Measure throughput
    let start = Instant::now();
    let target_count = 1000;

    for i in 0..target_count {
        let worker = DynamicWorker::new(
            &format!("perf-worker-{}", i),
            WorkerType::Docker,
            DynamicWorkerConfig::default(),
        );
        let _ = registration_adapter.register_worker(&worker).await;
    }

    let duration = start.elapsed();
    let throughput = target_count as f64 / duration.as_secs_f64();

    assert!(throughput > 100.0, "Throughput below 100 workers/sec: {}", throughput);
    println!("Registration throughput: {:.2} workers/sec", throughput);
}

#[tokio::test]
async fn test_memory_usage_under_load() {
    let scheduler = EmbeddedScheduler::new().await.unwrap();
    let scheduler_port = SchedulerPortClient::new(scheduler.channel());

    let registration_adapter = WorkerRegistrationAdapter::new(
        scheduler_port,
        RegistrationConfig::default(),
    );

    // Measure baseline memory
    let baseline_memory = get_memory_usage();

    // Register many workers
    for batch in 0..100 {
        let mut workers = Vec::new();
        for i in 0..50 {
            let worker = DynamicWorker::new(
                &format!("batch-{}-worker-{}", batch, i),
                WorkerType::Docker,
                DynamicWorkerConfig::default(),
            );
            workers.push(worker);
        }
        let _ = registration_adapter.register_workers_batch(workers).await;

        // Check memory every 10 batches
        if batch % 10 == 0 {
            let current_memory = get_memory_usage();
            let memory_increase = current_memory - baseline_memory;
            assert!(
                memory_increase < 100_000_000, // 100MB limit
                "Memory increased too much: {} bytes",
                memory_increase
            );
        }
    }

    // Final memory check
    let final_memory = get_memory_usage();
    let total_increase = final_memory - baseline_memory;
    assert!(total_increase < 50_000_000); // 50MB limit
}
```

### Test Helpers

```rust
/// Test utilities for auto-registration testing
pub struct TestFixtures {
    pub scheduler: EmbeddedScheduler,
    pub provider: MockWorkerProvider,
}

impl TestFixtures {
    pub async fn new() -> Self {
        Self {
            scheduler: EmbeddedScheduler::new().await.unwrap(),
            provider: MockWorkerProvider::new(),
        }
    }

    pub fn create_worker_with_config(
        &self,
        worker_id: &str,
        cpu_cores: u32,
        memory_mb: u32,
    ) -> DynamicWorker {
        let config = DynamicWorkerConfig::builder()
            .worker_type(WorkerType::Docker)
            .cpu_cores(cpu_cores)
            .memory_mb(memory_mb)
            .build()
            .unwrap();

        DynamicWorker::new(worker_id, WorkerType::Docker, config)
    }
}

fn get_memory_usage() -> usize {
    // Platform-specific memory usage measurement
    // This is a simplified implementation
    std::process::memory_info().unwrap().rss
}
```

---

## ðŸ“Š Success Metrics

### Test Coverage Metrics
- Unit test coverage: 100% (SchedulerPort, WorkerRegistrationAdapter)
- Integration test coverage: 95% (full flow scenarios)
- Contract test coverage: 100% (gRPC interfaces)
- Failure scenario coverage: 100% (all error paths)

### Performance Benchmarks
- Registration throughput: > 100 workers/second (target: 500)
- Registration latency p95: < 2 seconds
- Concurrent registration: 500 workers without errors
- Memory efficiency: < 50MB for 1000 workers
- Zero memory leaks detected

### Quality Metrics
- All integration tests passing: 100%
- Contract tests stable: 100%
- Test execution time: < 30 seconds
- Flaky test rate: 0%
- Test data isolation: 100%

---

**Story Status**: ðŸ“‹ Draft
**Created**: 2025-11-24
